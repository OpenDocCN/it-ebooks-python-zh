# 第四章 模块化编程

# 第四章 模块化编程

随着待解决的问题越来越复杂，程序也越来越复杂。对于复杂问题，如果仅仅依靠上一 章介绍的结构化编程方法，是很难驾驭程序的复杂性的。因为在控制结构这个层次上考虑程 序设计，必然因两方面的复杂性而导致编程困难：一是在广度上有成千上万行的代码，二是 在深度上有多层嵌套的控制结构。为了简化复杂程序在代码形式上的复杂性，以便在较高抽 象层次上把握复杂程序，计算机科学家提出了模块化编程方法。

# 4.1 模块化编程基本概念

## 4.1 模块化编程基本概念

# 4.1.1 模块化设计概述

### 4.1.1 模块化设计概述

模块化设计的思想在许多行业中早已有之，并非计算机科学所独创。

例如，建筑行业很早就提出了模块化建筑概念，即在工厂里预制各种房屋模块构件，然 后运到项目现场组装成各种房屋。模块构件在工厂中预制，便于组织生产、提高效率、节省 材料、受环境影响小。模块组装时施工简便快速、灵活多样、清洁环保，盖房子就像儿童搭 建积木玩具一样。①

再如，船舶工业广泛采用模块化造船方法，即对最终产品（整艘船舶）进行层次化分解， 并以中间产品（部件、分段、总段等）作为生产单元，最后再逐级组装成为最终产品。模块 化设计和建造能够使问题简化、结构优化、功能单元化、目标多样化，能够降低成本、缩短 周期，使产品易于维护、更新和系列化。

又如，现代电子产品功能越来越复杂、规模越来越大，利用模块化设计的功能分解和组 合思想，可以选用模块化元件（如集成电路模块），利用其标准化的接口，搭建具有复杂功 能的电子系统。模块化设计不但能加快开发周期，而且经过测试的模块化元件也使得电子系 统的可靠性大大提高，标准化、通用化的元件使得系统易构建、易维护。

总之，模块化设计和建造就是在对产品进行功能分析的基础上，将产品分解成若干个功 能模块，预制好的模块再进行组装，形成最终产品。这里，模块（module）是指提供特定功 能的相对独立的单元。模块一般具有如下特征：

*   标准化：模块是具有标准尺寸和标准接口的预制功能单元，这是组装、互换等特征 的基础。

*   可组装：多个模块可以方便、灵活地组合、配置，以构造不同大小、不同形状、不 同功能的系统。

*   可替换：通过用一个模块去更换另一个模块，可以改变系统的局部功能而不影响系 统的其他部分。

*   可维护：可以对模块进行局部修改或设置，以满足用户的需求。另外可以在现有系 统中增加新模块，以扩展系统功能。

模块化概念最早应用于工程技术领域，针对的是物理产品，后来逐渐演变成更广义的概 念，并在许多非物理产品领域中得到应用。尤其是在本书讨论的程序设计领域，模块概念和 模块化设计方法已经成为广泛采用的方法。

# 4.1.2 模块化编程

### 4.1.2 模块化编程

模块化编程（modular programming）是一种软件设计技术，它将软件分解为若干独立 的、可替换的、具有预定功能的模块，每个模块实现一个功能，各模块通过接口（输入输出 部分）组合在一起，形成最终程序。

> ① 远大公司在模块化建筑领域的两个案例：6 天建成 15 层宾馆，15 天建成 30 层的 T30 酒店。

对于简单问题，可以直接构建单一模块的程序。而对于复杂问题，则可以先创建若干个较小的模块，然后将它们组装、链接在一起，从而构成复杂的软件系统。模块化编程具有以 下优点：

*   易设计：较大的复杂问题分解为若干较小的简单问题，使我们可以从抽象的模块功 能角度而非具体的实现角度去理解软件系统，从而整个系统的结构非常清晰、容易 理解，设计人员在设计之初可以更加关注系统的顶层逻辑而非底层细节。

*   易实现：模块化设计适合团队开发，因为每个团队成员不需要了解系统全貌，只需 关注所分配的小任务。另外团队可以灵活地增加人手，新人只需直接接手某个模块， 不会影响系统其他模块的开发。

*   易测试：每个模块不但可以独立开发，也可以独立测试，最后组装时再进行联合测 试。

*   易维护：如果需要修改系统或者扩展系统功能，只需针对特定模块进行修改或者添 加新模块。

*   可重用：很多模块的代码都可以不加修改地用于其他程序的开发。

模块化编程实际上是一条抽象设计原则的具体体现，即分离关注点（Separation of Concerns，缩写为 SoC）原则。所谓关注点，是指设计者关心的某个系统特性或行为；而分 离关注点是指将系统分解为互不重叠的若干单元，每个单元对应于一个关注点。在模块化编 程中，以程序的各个功能作为关注点，模块划分就是分离关注点的结果。一个模块可以使用 另一个模块来实现自己的功能，但除此之外模块之间最好没有交互，这是 SoC 原则的理想 目标。

# 4.1.3 编程语言对模块化编程的支持

### 4.1.3 编程语言对模块化编程的支持

在 1950 年代，由于计算机内存容量很小，程序员们千方百计地想尽量减小程序的大小。 汇编语言中最早出现了子例程（subroutine）和宏（macro）的构造，其目的正是为了减小程 序大小。子例程和宏可以实现了“一次编写、多处多次使用”，从而避免了在程序中的重复 代码，缩短了代码长度。

从 1960 年代开始，高级编程语言中出现了支持模块化编程的语言构造，这种构造在不 同语言中可能有不同的名称和形式，除了上面提到的子例程之外，还有子程序（subprogram）、 过程（procedure）、函数（function）以及由过程和函数组成的模块、包（package）等构造。 以下我们用“子程序”来泛指这些模块化构造。

子程序是指程序中的一段代码，它执行特定任务，并且与同一程序中的其他部分是相对 独立的。顾名思义，子程序也是程序，也是由许多计算步骤构成的指令序列；但抽象地看， 可以将一个子程序视为一个操作或高级指令，可以作为更大的程序中的一个简单步骤来使 用。在程序的一次执行中，可以多次、多处执行子程序。子程序概念虽然仍然有避免重复代 码、减小程序大小的作用，但其更重要的目的是使程序更加模块化。

子程序构造一般涉及以下一些内容：

*   子程序的创建：定义子程序的名字和代码（程序体）。

*   子程序的调用和返回：调用就是要求执行子程序，而子程序执行完毕应当将控制返 回给调用者。

*   参数：相当于子程序所需的输入数据，一般需要预先声明参数的类型和个数，并在 调用时提供具体的参数值。

*   返回值：相当于子程序的输出数据，一般需要预先声明返回值的类型。

*   局部变量：子程序中定义的变量在子程序外部是不可见的，亦即子程序构成了一个 私有名字空间。这是子程序独立性的一种表现。

*   全局变量：子程序外部定义的变量如果被声明为全局变量，那么所有子程序都可以 共享使用、操作该变量。

有的编程语言（如 Pascal 语言）同时提供两种子程序构造：过程和函数。过程不产生 返回值，因此总体上相当于一条命令语句，只规定了要执行的操作；而函数不但要执行一些 计算，更重要的是需要将计算结果返回给调用者，因此函数在使用时相当于一个数据。

有的编程语言（如 C 语言）则不将子程序区分为过程和函数，而是统称为函数。过程 就是没有返回值的函数。不过，更现代的语言（如 Python）要求函数必须具有返回值，“过 程”其实是返回某种特殊值（如 Python 中的 None）的函数。

子程序是传统的过程式语言中的模块化构造。模块化编程方法经过多年发展，又派生出 了面向对象编程方法。在面向对象语言中，对象实际上就是模块概念的推广，传统模块之间 的调用接口相应地发展成了对象之间的消息传递接口。

一个编程语言一般只提供基本的编程构造（数据类型、语句、子程序等），用户所需的 实用功能都必须由自己编程实现。为了帮助用户进行应用开发，专业软件开发商一般会为某 种编程语言开发很多提供标准功能的子程序，用这种语言编程时可以直接调用这些标准子程 序。这些标准子程序构成了所谓的程序库，它是软件重用、共享和营销的重要形式。例如 math 和 string 就是 Python 语言的标准库。同样地，面向对象编程语言则以类库的形式 为程序员提供大量的标准功能代码。

总之，子程序是强大的模块化编程工具，通过将复杂程序分解为子程序，可以大大降低 开发复杂程序的难度，使问题变得可理解、易开发。另外，子程序的独立性还意味着可以由 团队来开发复杂程序，从而提高软件生产率。最后，由于较小的子程序更容易验证正确性， 所以模块化开发还可以保证复杂程序的质量和可靠性。

# 4.2 Python 语言中的函数

## 4.2 Python 语言中的函数

在数学中，函数是一种映射，其功能是将自变量的值（输入）映射到一个函数值（输出）。

编程语言中的函数是一段程序代码，其功能是根据输入（参数）进行计算，并产生输出（返 回值）。从上一节我们了解了模块化编程的一般知识，并且知道函数是一种常见的子程序构 造，是模块化编程的基本工具。对于 Python 语言，函数是最重要的语言构造之一，本节具 体介绍 Python 语言中的函数。

从前面几章，我们已经见过 Python 的一些内建函数（如 abs、len 等）、Python 标准库 中的函数（如 math.sqrt、string.split 等），下一章我们还会看到对象的方法也是一 种函数。本节要讨论的函数是用户自定义函数。

编程语言中为什么要引进用户自定义函数这种构造呢？

# 4.2.1 用函数减少重复代码 首先看一个简单的用字符画一棵树的程序：

### 4.2.1 用函数减少重复代码 首先看一个简单的用字符画一棵树的程序：

【程序 4.1】tree1.py

```
print "   *  " 
print "  ***  " 
print " ***** " 
print "*******" 
print "   *   " 
print "  ***  " 
print " ***** " 
print "*******"
print "   #   "
print "   #   "
print "   #   " 
```

执行结果如下：

```
 *   
  ***  
 ***** 
*******
   *   
  ***  
 ***** 
*******
   #   
   #   
   # 
```

尽管程序 4.1 实现了我们预定的功能，但从程序的形式、风格角度看，还是有不足之处。 从程序可见，代码的 1～4 行和 5～8 行是完全相同的①，它们对应于树冠的上下两部分。一 个程序中如果多处出现相同代码，会带来三个问题：第一，重复输入相同代码很烦人；第二， 重复代码使程序不必要地增加长度；第三，也是最重要的一点，代码维护很麻烦。前两条很 容易理解，我们来说明一下第三点。代码维护是指修改代码等工作。当要修改的代码在多处 重复出现时，显然必须在每一个重复出现处做统一的修改，以保持重复代码的一致性，这就 增加了代码维护的难度。

对程序 4.1 来说，重复代码很少，不算什么大问题。然而，如果重复代码很长、重复次 数很多，上述三个问题就不是可以忽视的了。事实上，多次键入重复代码至少会增加输入出 错的可能性，而维护重复代码时也很容易忘记在各处统一修改，这些都会导致重复代码的不 一致。至于重复代码使程序拖沓冗长，就更不必说了。

如何解决这种重复代码问题呢？函数正是我们所需的语言构造。 我们已经知道，函数是一个子程序，其基本思想是将一个语句序列看作一个整体，并为

该语句系列命名。此后，在程序中的任何地方，只要引用该函数名，就能执行函数的语句序 列。创建函数的代码称为函数定义，以后使用函数的代码称为函数调用。

下面我们定义一个函数 treetop()，它的语句序列正是程序 4.1 中的重复代码。注意， 为了更直观地介绍函数定义及其调用，我们特意在 Python 交互环境 IDLE 中来展示有关内 容。

```
>>> def treetop():
    print "   *   " 
    print "  ***  " 
    print " ***** " 
    print "*******" 
```

def 语句只是定义了新函数 treetop，并没有执行函数体中的语句，因此不会产生显 示输出。直到调用 treetop 函数时，才执行函数体。我们来看看它的功能是什么。

> ① 如果读者自己在文本编辑器中键入这个程序，一定会使用“复制－粘贴”功能吧。

```
>>> treetop()
   *
  ***
 *****
******* 
```

可见函数 treetop 正确地打印了树冠的一部分。 接下来定义画出整棵树的函数 tree：

```
>>> def tree():
    treetop() 
    treetop() 
    print "   #"
    print "   #"
    print "   #" 
```

由于重复代码被函数调用 treetop 代替，这个版本显然比原先的版本简练许多，但程序的 功能完全是一样的，参见下面的运行结果：

```
>>> tree()
   *
  ***
 *****
*******
   *
  ***
 *****
*******
   #
   #
   # 
```

至此我们用函数解决了重复代码的问题。要注意的是，我们是在交互环境下展示函数定 义和调用的，因而可以先定义函数 treetop 并单独运行此函数，然后再定义主函数 tree 并运行之。如果按通常的做法将代码保存为程序文件，则应将两个函数合并为一个程序文件 来保存，因为它们不过是一个程序的两个部分而已。即如程序 4.2 所示。

【程序 4.2】tree2.py

```
def treetop(): 
    print "   *   " 
    print "  ***  " 
    print " ***** " 
    print "*******"
def tree():
    treetop() 
    treetop() 
    print "   #"
    print "   #"
    print "   #"
tree() 
```

顺便说明一下，程序 4.2 中定义了两个函数，其中 tree 是主函数，用于完成程序的总 体功能，而 treetop 是辅助性的函数（子程序），用于完成部分功能。其中最后一行是调 用主函数，这是启动整个程序的入口。作为惯例，我们通常将一个程序的主函数（程序入口） 命名为 main。今后，我们给出的例子程序即使并未定义辅助性的函数，我们也将所有代码 置于一个主函数 main 之中，这是惯例，也符合模块化编程的风格——程序至少由一个主控 模块构成。

有的读者也许会问，程序 4.2 中的函数 tree 中，还存在三条重复出现的语句

```
print "   #" 
```

为何不定义一个函数来避免重复呢？我们不妨再写一个新版本，读者看了之后自然明白这个 做法没什么好处。见下：

```
def treetop(): 
    print "   *" 
    print "  ***" 
    print " *****" 
    print "*******"
def printhash(): 
    print "   #"
def tree():
    treetop() 
    treetop() 
    printhash() 
    printhash() 
    printhash()
tree() 
```

从这个版本可以看出，由于重复的代码只是一条语句，如果为重复代码定义一个新函数， 不但不能使代码精简，反而使代码变复杂了。更重要的是，利用函数来取代重复代码不是没 有代价的，因为函数调用和返回都需要花费系统开销。这个版本花了代价，却没有带来任何 收益，所以是不合适的。

# 4.2.2 用函数改善程序结构

### 4.2.2 用函数改善程序结构

上一节讨论了函数的减少重复代码、精简程序的作用，并利用函数的这个功能将程序 4.1 改进成了程序 4.2。在该节的最后，我们也给出了一个不宜用函数来减少重复代码的情况。

还能不能利用函数将程序 4.2 变得更好呢？

我们在 4.1 节中一般地讨论了模块化编程，在 Python 中，函数就是用于模块化编程的 重要工具。当算法很复杂时，程序就会变得难以理解。据说人类擅长同时应付 8 到 10 件事 情，当面对成百上千行的算法时，最好的程序员也会感到难以把握。应对程序复杂性的一种 方法就是模块化，将程序分解成多个较小的相对独立的子程序。下面我们来看程序 4.2 还能 怎样改进。

我们定义一个新函数 treetrunk，它的语句序列就是程序 4.2 的主函数中用于画树干的三条 print 语句。即：

```
def treetrunk(): 
    print "   #"
    print "   #"
    print "   #" 
```

然后我们用这个函数取代主函数的那三条 print 语句，就得到画树程序的一个新版本。

【程序 4.3】tree3.py

```
def treetop(): 
    print "   *" 
    print "  ***" 
    print " *****" 
    print "*******"
def treetrunk(): 
    print "   #"
    print "   #"
    print "   #"
def main():
    treetop() 
    treetop() 
    treetrunk()
main() 
```

注意我们将程序主函数的名字从 tree 改成了更符合惯例的 main。

简单地比较一下程序 4.2 与 4.3 这两个版本就看出，由于多了函数 treetrunk 的定义与调用，新版本的代码不但没有减少，反而增加了。那为何要引进 treetrunk 函数呢？其实我们的目的是使主程序的结构更清晰，从而更容易理解程序功能。通过将一些实现细节转移到一个单独的函数中，并对函数进行合适的命名，能够使程序的可读性大大增强。例如我 们来读程序 4.3 的主程序 main，就会发现该程序不过是先画树冠（由两个相同形状组成）， 再画树干而已，程序的功能一目了然。

如果进一步发挥上述思想，就会发现程序 4.3 的结构还不够完美。问题出在主程序的第 一步——画树冠，这一项任务逻辑上是个整体却用了两个函数调用来完成，这就好比老师对 学生说“请大家画上一半树冠，再画下一半树冠”，显然不如直接说“请大家画树冠”来得 清晰易懂。因此，我们再引入一个新函数用于隐藏树冠的实现细节（上下两部分），从而得 到程序 4.4，这个版本在避免重复代码和模块化两方面可以说达到了完美。

【程序 4.4】tree4.py

```
def treetop1(): 
    print "   *" 
    print "  ***" 
    print " *****" 
    print "*******"
def treetop():
    treetop1() 
    treetop1()
def treetrunk(): 
    print "   #"
    print "   #"
    print "   #"
def main():
    treetop() 
    treetrunk()
main() 
```

现在再来读主程序 main，显然更容易理解了——从程序顶层看，整个程序不外乎就是画树 冠、画树干两步而已。如果只想了解程序的总体功能，那么读懂 main 函数就够了；如果还 想了解更多细节，那就再去读辅助函数 treetop1 和 treetrunk 等。

读者在编程时应当多模仿、多体会程序 4.4 中函数的用法，并学会欣赏模块化程序在结 构方面的优美。

# 4.2.3 用函数增强程序的通用性

### 4.2.3 用函数增强程序的通用性

我们说过，程序 4.4 在减少重复代码和模块化两方面已经做得很好，但这并不意味着该 程序在各方面都已经完美。例如，如果我们希望换用字符"^"再画一棵树，以便比较哪个更 好看些，该如何做呢？显见的做法是仿照用"*"画树的代码重写画树冠的函数，而树干部分 可以重用。于是得到下面的代码：

【程序 4.5】tree5.py

```
def treetop1(): 
    print "   *" 
    print "  ***" 
    print " *****" 
    print "*******"
def treetop2(): 
    print "   ^" 
    print "  ^^^" 
    print " ^^^^^" 
    print "^^^^^^^"
def star_treetop(): 
    treetop1() 
    treetop1()
def caret_treetop(): 
    treetop2() 
    treetop2()
def treetrunk(): 
    print "   #"
    print "   #"
    print "   #"
def main():
    star_treetop() 
    treetrunk() 
    print 
    caret_treetop() 
    treetrunk()
main() 
```

此版本的执行结果如下：

```
 *
  ***
 *****
*******
   *
  ***
 *****
*******
   #
   #
   #
   ^
  ^^^
 ^^^^^
^^^^^^^
   ^
  ^^^
 ^^^^^
^^^^^^^
   #
   #
   # 
```

虽然程序 4.5 满足了功能需求，但是从程序设计角度说是很笨拙的，因为这是一种“头 痛医头脚痛医脚”的方法，即为每一种特殊情形创建新的代码。更好的做法是用一个一般的 函数来处理所有特殊情形。鉴于 treetop1 和 treetop2 的非常类似，我们可以从他们抽 象出一个通用的画树冠的函数，使得该函数能够取代 treetop1 和 treetop2。

函数的通用性可以通过引入参数（parameter）来实现。要理解参数的作用，可以简单地与数学函数的自变量进行类比。以函数 f(x) = x2 为例，对于给定的自变量值 10，函数计算 出函数值 f(10) = 100；换不同的自变量值 20，则函数又计算出另一个函数值 f(20) = 400。编 程语言中的函数参数具有类似的行为，输入不同的参数值，则函数执行后可产生不同的结果。

下面我们设计一个通用的画树冠的函数 treetop(ch)，其中参数 ch 表示用来作画的 字符。为了控制树的形状，函数定义中使用了字符串格式化运算。

```
>>> def treetop(ch):
        print " %s" % (ch) 
        print " %s" % (3 * ch) 
        print " %s" % (5 * ch) 
        print "%s" % (7 * ch) 
```

在交互环境定义了函数 treetop(ch)后，我们接着来测试它的效果。下面是测试例子：

```
>>> treetop('*')
   *
  ***
 *****
*******
>>> treetop('^')
   ^
  ^^^
 ^^^^^
^^^^^^^
>>> treetop('A') 
   A
  AAA 
 AAAAA 
AAAAAAA 
```

可见函数 treetop(ch)确实具有通用性，只要为它的参数提供一个字符值，就能用该字符 画出树冠形状。下面我们利用 treetop(ch)函数来改写程序 4.5：

【程序 4.6】tree6.py

```
def treetop(ch):
    print " %s" % (ch) 
    print " %s" % (3 * ch) 
    print " %s" % (5 * ch) 
    print "%s" % (7 * ch)
def star_treetop(): 
    treetop("*")
    treetop("*")
def caret_treetop(): 
    treetop("^")
    treetop("^")
def treetrunk(): 
    print " #"
    print " #"
    print " #"
def main():
    star_treetop() 
    treetrunk() 
    print 
    caret_treetop() 
    treetrunk()
main() 
```

此版本的执行结果和程序 4.5 完全一样，但是比较两者的代码会发现，程序 4.6 将程序 4.5

中的两个函数合二为一，增强了通用性。以后如果想换用其他字符画树，修改程序 4.6 比修

改程序 4.5 要简单得多。

# 4.2.4 小结：函数的定义与调用

### 4.2.4 小结：函数的定义与调用

通过前面的例子，读者应该已经非常熟悉 Python 中函数定义的语法。在此总结如下：

```
def <函数名>(<形式参数>):
    <函数体> 
```

其中函数名是标识符，命名必须符合 Python 标识符的规定；形式参数是用逗号分隔的变量名序列（可以为空）。函数体是语句序列，左端必须缩进一些空白。 一旦定义了一个函数，就可以在程序的任何地方调用这个函数。函数调用的语法如下：

```
<函数名>(<实际参数>) 
```

其中实际参数可以是表达式，个数必须和形式参数相同。注意，这里列出的函数调用语法实 际上适用于没有返回值的函数，即 4.1.3 节中提到的“过程”。4.2.6 小节会讨论具有返回值 的函数。

当 Python 遇到一个函数调用时，将通过四个步骤来处理这个调用。假设程序 P 现在执 行到了一个函数调用 f(a)，则这四个步骤是：

（1）调用者 P 在调用点暂停执行（术语也称为 P 挂起）；

（2）函数 f 的形式参数被赋予实际参数 a 的值；

（3）执行 f 的函数体；

（4）f 执行完毕后，控制返回到 P 中调用点的下一条语句。

下面我们以程序 4.6 为例，具体描述函数调用过程。为了方便阅读，将程序 4.6 的主函 数 main 罗列在下面，整个程序从 main 开始执行。

```
def main():
    star_treetop() 
    treetrunk() 
    print 
    caret_treetop()
    treetrunk() 
```

当 Python 执行到 star_treetop()时，main 暂停执行，控制转到 star_treetop。 因为没有参数传递问题，所以直接执行 star_treetop 的函数体。图 4.1 描述了这个函数 调用的控制转移情况。

![](img/程序设计思想与方法 118883.png)

图 4.1 控制从 main 转移到 star_treetop

控制转到 star_treetop 后执行的第一条语句又是一个函数调用 treetop("*")， 于是 Python 又暂停执行 star_treetop，而将控制转到 treetop("*")。Python 检查 treetop 的定义后发现它有一个形式参数 ch，于是将函数调用 treetop("*")的实际参 数"*"传递给形式参数 ch，这相当于在 treetop 的函数体之前增加了一条赋值语句：

```
ch = "*" 
```

参数传递后开始执行 treetop 的函数体。图 4.2 展现了这时的状态，注意 treetop 内部的变量 ch 已经被赋值为"*"。

![](img/程序设计思想与方法 119205.png)

图 4.2 控制从 star_treetop 转移到 treetop

由于 treetop()的函数体是一系列 print 语句，没有更多函数调用，于是 Python 顺 序执行这些语句，结束后将控制返回到 treetop 调用点的下一条语句，即 star_treetop 中的第二条 treetop("*")语句，这时的情形参看图 4.3。注意，当函数执行完毕，函数的 变量所占用的存储空间将被 Python 收回，任何变量都不可能将数据保持到下一次执行函数， 故图 4.3 中 ch 显示为未赋值状态。

![](img/程序设计思想与方法 119465.png)

图 4.3 控制从 treetop 返回 star_treetop

接下来执行 star_treetop 的第二条 treetop("*")，其过程和前面一条完全一样， 我们就不作图演示了。现在，当控制从 treetop 再次返回 star_treetop 时，此函数也 执行完毕，故控制又返回到 main 函数中调用点的下一条语句。如图 4.4 所示。

![](img/程序设计思想与方法 119649.png)

图 4.4 控制从 star_treetop 返回 main

控制返回 main 后执行的是第二条语句 treetrunk()，这又是一个函数调用。于是 main 再次暂停执行，控制转移到函数 treetrunk。treetrunk 执行完毕控制返回 main， 执行第三条语句 print，输出一个空行后执行函数调用 caret_treetop()。这和前面 star_treetop()的执行过程是类似的，控制转移到 caret_treetop 的函数体后遇到的 是 treetop("^")，这次传递给形式参数 ch 的值是字符"^"，图 4.5 表示了此时的状态。

![](img/程序设计思想与方法 119685.png)

图 4.5 控制从 caret_treetop 转到 treetop 并传递不同实际参数

此后的执行过程与上述类似，我们不再逐一说明。当程序最后一行的调用 treetrunk 执行完毕，控制返回到 main 时到达程序末尾，于是整个程序结束。其实，main 本身也是一个函数，程序 4.6 的最后一行就是对 main 的调用。由于 main 是顶层模块，调用并执行 main 后控制只能返回给 Python——所以整个程序执行完毕后我们看到的是熟悉的“>>>”。

以上我们通过例子描述了 Python 的函数定义和调用。还要说明一点，函数定义中提到 形式参数可以是用逗号分隔的变量名序列。对于有多个形式参数的函数，调用时一定要注意 形式参数与实际参数的匹配。简单的做法是按位置匹配，即调用时提供的第一个实际参数赋 值给第一个形式参数，第二个实际参数赋值给第二个形式参数，依此类推。

作为例子，我们再来研究用字符画树冠的问题。树冠是由两个三角形图案组成的，程序 4.2 或程序 4.6 中，函数 treetop 的功能就是用字符画三角形图案，只不过程序 4.2 固定用 字符"*"画画，程序 4.6 可以用任意字符画画。观察 treetop 的函数体，可见图案是由多 条 print 语句所打印的字符串拼成的，并且每条 print 所打印的字符串很有规律：每行中 "*"的个数是自顶向下分别是 1、3、5、7，而左边留的空格数自顶向下分别是 3、2、1、0。 对这些数字做一点分析，很容易得出规律：设树冠最宽处有 w 个"*"字符，则当某一行上要 画 c 个"*"时，该行左边留的空格数就是(w - c) / 2。根据这个规律，我们定义一个新的 treetop 函数，它具有两个参数：一个是画图所用字符 ch，另一个是树冠宽度 width（为 对称起见应该用奇数，此前例子都固定为 7）。显然这个新的 treetop 函数更加通用化，可 以用任意字符画任意宽度的树冠。

```
def treetop(ch,width):
    for c in range(1,width+1,2):
        print ((width–c)/2) * " " + c * ch 
```

下面我们在 Python 交互环境下定义这个函数，然后做一些测试。结果如下：

```
>>> treetop("*",7)
   *
  ***
 *****
*******
>>> treetop("@",9)
    @
   @@@
  @@@@@
 @@@@@@@
@@@@@@@@@
>>> treetop(11,"A")
Traceback (most recent call last):
File "<pyshell#9>", line 1, in <module> treetop(11,"A")
File "<pyshell#2>", line 2, in treetop for c in range(1,width+1,2):
TypeError: cannot concatenate 'str' and 'int' objects 
```

从上例可知，由于函数 treetop 有两个形式参数，因此调用该函数时必须传递两个实 际参数与之匹配。参数传递的效果相当于在 treetop 的函数体前面执行了两条赋值语句：

```
ch = ...
width = ... 
```

如果实际参数与形式参数不匹配，函数执行就可能出错，如上例中的 treetop(11,"A")。 更严重的是函数执行似乎没有出错，但参数的错误匹配实际上导致计算结果完全没有意义。

例如我们定义一个显示身高体重信息的函数，然后调用之：

```
>>> def printInfo(height,weight): 
        print "Height:",height 
        print "Weight:",weight
>>> printInfo(80,1.80)
Height: 80
Weight: 1.8 
```

可见，由于调用时参数传递不匹配，函数虽然能够执行，但结果无意义。

关键字参数

函数调用时的参数传递通常采用上述“按位置匹配”的方式，但 Python 还提供另一种 参数传递方式——关键字参数。关键字参数形如“<形参名> = <实参值>”，即通过形式参数 的名字来指示为哪个形参传递什么值。例如：

```
>>> treetop(width = 11,ch = "A")
     A 
    AAA 
   AAAAA 
  AAAAAAA
 AAAAAAAAA 
AAAAAAAAAAA 
```

关键字参数在某些场合用起来更方便。例如，如果一个函数有很多参数，但是调用时只 想为个别参数传递值，而其他参数采用缺省值，这是采用关键字参数就是必然的选择。下面 是一个简单的例子：

```
>>> def f(a,b=7,c=2):
        print a,b,c
>>> f(2005)
2005 7 2
>>> f(1927,8,1)
1927 8 1
>>> f(1921,c=1)
1921 7 1 
```

注意，这个例子同时说明了如何为函数参数指定缺省值。

# 4.2.5 变量的作用域

### 4.2.5 变量的作用域

程序中的变量都有自己的作用域（scope，或称辖域），即程序的一部分区域，在其中可以访问该变量。一个变量只有在它的作用域中才有定义，才能被访问。

局部变量

在一个函数中定义的变量称为局部变量（local variable），因为它们的作用域局限于该 函数的函数体，在函数外部是没有定义的。例如：

```
>>> def func(x,y):
        z = x + y print z
>>> func(1,2)
3 
```

函数 func 中定义了局部变量 z。由于语句 print z 是 func 函数体内的语句，所以 可以访问 z。如果函数外部的 print 语句试图显示 z 的值，则会出错。例如接着上例继续 执行：

```
>>> print z
Traceback (most recent call last):
File "<pyshell#9>", line 1, in <module> print z
NameError: name 'z' is not defined 
```

函数的形式参数也可以看作是函数的局部变量，即只能在函数体内访问。形式参数不同 于局部变量的是：形式参数的值是在调用函数时通过参数传递而来的。如上例中函数 func 有两个参数 x 和 y，当调用 func(1,2)时相当于执行了两个对局部变量的赋值语句 x = 1 和 y = 2。

函数的局部变量和形式参数仅在函数体内有定义，因此即使与函数外部的变量同名也不 会带来问题。例如我们接着上例继续执行语句：

```
>>> x = 1
>>> z = 2
>>> func(x,z)
3 
```

这里，x 和 z 是在函数 func 的外部定义的变量，它们虽然分别与 func 的形式参数 x 和局 部变量 z 同名，但实际上毫无联系。执行 func(x,z)时，Python 先在 func 外部计算 x 和 z 的值，然后将结果传递给 func 的形式参数 x、y，因此最终执行的是 func(1,2)。图 4.6 给出了这个过程的示意图。

![](img/程序设计思想与方法 122746.png)

图 4.6 函数局部变量与外部变量同名 全局变量

函数内部的变量具有局部性，这符合模块化编程思想的要求。作为一种模块化构件，函 数就像“黑盒”一样，其内部细节应该对外部不可见。同理，函数内部也不应直接使用外界 的东西。如果函数需要外界的数据，正确的做法是通过参数来传递给函数。也就是说，函数 的参数除了用于表示可变数据、增强函数的通用性之外，还应作为外界向函数传递数据（即使是一个固定不变的数据）的唯一渠道。下面是一个函数直接使用外界数据的例子：

```
>>> s = "hello"
>>> def f():
        print s
>>> f()
hello 
```

这里，函数 f()的功能是打印变量 s 的值，但这个 s 并不是 f()自己的局部变量，而是 f() 外部的变量，相对于 f()可称为全局变量（global variable）。尽管这个用法在 Python 中是合 法的，但这不是好的编程风格。正确的做法是将变量 s 的值通过参数传递给 f()：

```
>>> s = "hello"
>>> def f(x):
        print x
>>> f(s)
hello 
```

在实际应用中，可能会有多个函数共同操作（读取或修改）一个数据的情形，这时采用 参数传递的方式比较麻烦，而采用全局变量则显得直接了当。下面我们用一个简单程序说明 Python 中全局变量的用法。

【程序 4.7】eg4_7.py

```
def f():
    global x 
    x = x + 1 
    print x
def g():
    global x 
    x = x - 1 
    print x
    x = 0 
f()
g() 
```

程序中定义了两个函数 f()和 g()，它们的函数体中都包含一条声明全局变量的语句： global x 意为本函数中所使用的 x 是在函数外部定义的全局变量。f()的功能是对全局变量 x 加 1，g()的功能是对全局变量 x 减 1。执行结果如下：

```
>>> import eg4_1
1
0 
```

可见执行 f()之后 x 变成了 1，再执行 g()又把 x 改回了 0。

# 4.2.6 函数的返回值

### 4.2.6 函数的返回值

函数作为一种模块构件，它与其他模块如何协作、交换信息？我们已经知道，通过函数 调用时的参数传递，可以实现从函数外部向函数内部输入数据。本节讨论函数向外部输出信 息的问题。

在数学中，函数是从定义域到值域的映射，亦即从自变量计算出函数值。编程语言中的 函数原本就是数学函数的模仿物，自然也可以计算出一个结果输出给函数调用者，我们称函 数输出的计算结果为函数的返回值（returned value）。

在前面几章中，我们已多次使用过具有返回值的内建函数和库函数。例如，内建函数 len() 能够接收一个字符串，然后返回该字符串的长度；数学库中的函数 math.sqrt()接收一个 数值，并返回该数值的平方根。我们还看到，带有返回值的函数基本上可以当作一个值来看 待，可以和其他数据一起进行运算，构成表达式。例如：

```
(-b + math.sqrt(b*b – 4*a*c)) / 2*a 
range(len("hello"))
x = input("Enter a number:") 
```

如何自定义带有返回值的函数呢？Python 语言提供了一条 return 语句用于从函数返 回值，用法如下：

```
def f():
...
return <表达式 1>, ..., <表达式 n>
... 
```

其语义是：当 Python 在执行函数 f()时，一旦遇到 return 语句，就终止执行函数，并将 控制返回到函数调用点，同时将各表达式的计算结果返回给调用者。

与 Python 内建函数、库函数一样，带返回值的用户自定义函数可以像一个普通的数据 值一样使用，例如用在表达式中参加运算（当然要求数据类型合法）或者作为赋值语句的右 端为变量赋值。

例如，下面的函数实现了数学函数 f(x) = x2 的功能：

```
>>> def sq(x):
        return x * x
>>> sq(2)
4
>>> print sq(3) + 1
10
>>> a = 4
>>> b = sq(a)
>>> print b
16 
```

再看一个例子，下面的 dist()函数能够计算平面上两点间的距离。我们将平面上的点 表示为由横坐标和纵坐标组成的元组(x,y)。根据数学中的距离公式，并利用上面的 sq() 函数，可以写出如下代码：

```
>>> import math
>>> def dist(u,v):
        d = math.sqrt(sq(v[0]-u[0])+sq(v[1]-u[1])) return d
>>> dist((0,0),(4,0))
4.0
>>> dist((0,0),(0,5))
5.0
>>> dist((0,0),(1,1))
1.4142135623730951
>>> dist((1,2),(3,4))
2.8284271247461903 
```

如果函数返回值有多个，那么调用者需要使用多个变量来接收函数的返回值。例如下面 的函数 headtail()对一个列表取出头尾元素：

```
>>> def headtail(list):
    return list[0], list[len(list)-1]
>>> headtail([1,2,3,4,5]) 
(1, 5) 
```

调用 headtail 这种返回多个值的函数时，调用者可以利用多变量同时赋值语句来接

收多个返回值，也可以只用一个变量来接收返回值，因为函数返回的“多个值”实际上构成

一个元组。

```
>>> h,t = headtail([1,2,3,4,5])
>>> print h,t 
1 5
>>> v = headtail([1,2,3,4,5])
>>> v 
(1, 5) 
```

函数中的 return 语句通常都出现在函数的末尾，因为函数一般都是执行完所有步骤 之后才能得出计算结果并返回。然而，有时我们希望在函数到达末尾之前就终止执行并返回， 例如当函数检测到不正确的数据时就没有必要继续执行，因为计算下去只能带来错误结果。 下面这个例子检查用户输入（要求是正数），如果不满足要求则退出函数，否则对用户数据 进行处理。代码如下：

```
>>> def f(x):
    if x <= 0:
        print "Positive numbers only, please." 
        return
    y = x ** 3 
    return y
>>> f(0)
Positive numbers only, please.
>>> f(2) 
8 
```

最后要说明一点，在 Python 中，任何函数无论是否包含 return 语句，总是要返回一个值的。如果包含 return 语句，自然就返回程序员指定的值；如果不含 return 语句， 则函数总是返回一个称为 None 的特殊对象。如果编程时忘记在函数中用 return 语句返回 值，而调用处又企图使用返回值，则可能出错。例如，假设上面定义的 dist()函数忘了最 后的 return 语句，我们看会带来什么后果：

```
>>> import math
>>> def dist(u,v):
        d = math.sqrt(sq(v[0]-u[0])+sq(v[1]-u[1]))
>>> print dist((0,0),(2,2))
None
>>> print 2 + dist((0,0),(2,2))
Traceback (most recent call last):
File "<pyshell#42>", line 1, in <module> print 2 + dist((0,0),(2,2))
TypeError: unsupported operand type(s) for +: 'int' and 'NoneType' 
```

可见调用 dist()后得到的结果是 None；如果将这个 None 用于表达式中（例中是与 2 相 加）则可能出错，因为对 None 对象并没有定义加法运算。对初学 Python 编程的人来说， 这是容易犯错的地方，所以一定要注意返回值。

# 4.3 自顶向下设计

## 4.3 自顶向下设计

采用传统过程式语言进行模块化编程时，主要通过自顶向下方法来进行系统设计。 自顶向下设计也称为逐步求精（stepwise refinement），是将一个系统逐层分解为子系统的设计过程。首先，对整个系统进行概要设计，指明构成系统的顶层子系统有哪些，注意在 此并不给出各个子系统的细节。其次，对每个子系统重复这个设计过程，即再将每个子系统 分解为下一层的子系统。就这样不断细化每个子系统，直至子系统的功能足够简明，可以直 接编码实现为止。

自顶向下设计具有两个特征：第一，要求设计者一开始就对整个系统有清楚的理解，否 则第一步的分解就无法进行；第二，任何子系统在足够细化之前无法开始编码实现，因而必 须等到所有子系统都足够细化，才可能对系统编码实现及测试。

更具体地说，用自顶向下方法编程序时，总是先写主程序，它是由根据系统功能划分而 成的功能子程序组成的。然后再分析每个子程序的需求，如果有必要就继续像主程序一样分 解下去。当划分出来的子程序最终具有非常简单的功能时，就直接编码实现。当所有子程序 都编码实现，整个程序也就实现了。可以相信，由于分解过程总是导致越来越小的程序部件， 最终必然达到“足够简单”的层次，因此不可能无限分解下去。

下面通过一个案例程序来演示自顶向下设计方法。 我们要解决的问题是打印公元某年的年历。要说明一点，为了避免涉及公元历法的一些历史变迁问题，我们对需求做了简化，只要求程序适用于公元 1900 年以后各年份①。相应程 序的规格说明如下：

> ① 程序算法实际上是一般的。将基准日期换成格里高利历的开始日（1582 年 10 月 15 日，星期五）后，很 容易扩展本程序的适用年份范围。

```
程序：calendar
输入：公元年份 year（1900 以后）
输出：year 年年历
输入与输出的关联：根据 year 可以算出相对于 1900 年 1 月 1 日（星期一）总共过去了多少天，按 7 天循环即可得知 year 年 1 月 1 日是星期几，从而得出全年年历。 
```

# 4.3.1 顶层设计

### 4.3.1 顶层设计

根据 calendar 程序的规格说明，很容易设计一个简单的 IPO 模式的算法：首先从用户处 获得年份输入 year，然后计算该年份 1 月 1 日是星期几，最后按特定格式输出年历。我们用 伪代码来表示该算法，如下：

```
输入 year
计算 year 年 1 月 1 日是星期几 输出年历 
```

这个算法属于高层设计，其中第二、第三两个步骤都不是一目了然能直接编码实现的， 但我们不妨假设每个步骤都由一个函数实现，从而可以利用这些函数实现程序。

首先，尽管第一个步骤“输入 year”看上去很容易用 input 语句实现，但我们仍然先 用一个顶层模块——函数 getYear()来表示该步骤的实现。函数 getYear()负责从用户 处获得输入并返回给主程序使用，因此我们将函数的返回值赋值给主程序变量 year。至此， 我们的 calendar 程序取得了第一个进展：

```
def main():
    year = getYear() 
```

其次，计算 year 年 1 月 1 日是星期几，这个步骤不是那么显然，但我们仍然假设函数 firstDay()能够实现该步骤，这个函数以 year 作为输入，然后返回一个代表星期几的值（例如，用 0 表示星期天，用 1 到 6 分别表示星期一到星期六）。在主程序中添加一行调用 firstDay()的语句，并将函数返回值赋值给主程序变量 w，这时程序就进展到如下形式： def main():

```
year = getYear() w = firstDay(year) 
```

最后一步是输出年历，仍然假设函数 printCalendar()能够实现该步骤，此函数需要用到的信息包括 year 和 w，无需提供返回值。在 main 中添加相应的函数调用语句之后，得到 calendar 程序的完整结构如下：

```
def main():
    year = getYear()
    w = firstDay(year) 
    printCalendar(year,w) 
```

至此，我们做出了 calendar 程序的顶层设计，将原始问题分解成了三个模块，当然各模块的细节尚不清楚。主程序虽然只有寥寥 3 行，看上去不过是上面的算法伪代码略加细化的 结果，但它确实满足程序规格说明的要求。此外，我们还为对应每个模块的函数声明了函数 名、参数和返回值，这些信息构成了函数的接口（interface）。在 main 这个层次，并不需要 关心 getYear()等函数的实现细节，只需要关注它们对于给定的参数能返回预定的数据。 亦即，只关心每个子程序“做什么”，而非“怎么做”。函数接口正是表达“做什么”信息的。

自顶向下设计中经常使用一种设计工具——结构图（或称模块层次图），其中用矩形表 示程序模块，用两个矩形之间的连线表示模块间的调用关系，在连线旁边用箭头和标注来指 明模块之间的界面信息。各模块分别处于不同层次，高层模块是调用模块（或控制模块）， 低层模块是被调用模块（或受控模块）。结构图最顶层就主程序（总控模块）。例如，calendar 程序的顶层设计可以用如图 4.7 所示的结构图来表示。

![](img/程序设计思想与方法 128488.png)

图 4.7 calendar 程序的顶层结构图

在结构图中，越处于下层的模块，其细节程度就越高，即更加精化。

# 4.3.2 第二层设计

### 4.3.2 第二层设计

接下来需要对第二层上的每个模块进行精化。

首先看 getYear 函数。这个函数的功能只是输入年份数据，可以直接用 Python 的基本 语句实现，无需分解为新的功能模块。具体代码如下：

```
def getYear():
    print "This program prints the calendar of a given year." 
    year = input("Please enter the year (after 1900): ") 
    return year 
```

接着考虑 firstDay 函数的设计。这个函数的功能是计算 year 年 1 月 1 日是星期几，因为年历是按星期来组织每一天的显示位置的，而只要知道 1 月 1 日的显示位置，其后所有日期的显示位置也就确定了。

在 calendar 程序的规格说明中说明了，我们以 1900 年 1 月 1 日（星期一）作为基准日， 只要算出 year 年 1 月 1 日距离基准日的天数，就能知道这一天是星期几。因为从基准日开 始，过 1 天是星期二，过 2 天是星期三，…，过 6 天是星期日，过 7 天又是星期一，…。一 般地，过 n 天是星期(n+1)%7（值为 0 表示星期天）。

那么，从基准日到 year 年 1 月 1 日总共过了多少天呢？只需一点常识，就能得出下面 的公式：

```
(year – 1900) * 365 + k 
```

其中 k 是从 1900 到 year（不含）之间的闰年个数。

看上去闰年个数 k 还不清楚如何求得，我们按惯例假设一个新函数 leapyears()能够

返回所需的 k。于是可以设计 firstDay 函数如下：

```
def firstDay(year):
    k = leapyears(year)
    n = (year – 1900) * 365 + k 
    return (n + 1) % 7 
```

最后考虑 printCalendar 函数的设计，该函数的任务是在合适的位置按日历格式显示一年 12 个月的日历。由于问题有点复杂，我们照例进行任务分解。12 个月的日历输出显然可以用一个 for 循环来实现，循环体是显示一个月日历的代码。每个月需要先打印标题（月份和星期的名称），然后再打印日期，假设函数 heading()和 oneMonth()分别执行这两个任务，则 printCalendar 的代码如下：

```
def printCalendar(year,w):
    print
    print "=========== " + str(year) + " =========="
    first = w
    for month in range(12): 
        heading(month)
        first = oneMonth(year,month,first) 
```

函数体的第一行用于打印年份信息，接下去是打印 12 个月的日历的 for 语句。打印每个月 的日历需要知道该月 1 日是星期几。printCalendar 的参数 w 是前面算出来的 1 月 1 日 的星期信息，2 月到 12 月的 1 日则由 oneMonth 函数返回至此，我们完成了第二层设计， 可以用图 4.8 中的结构图表示到目前为止的设计结果。注意，为简明起见，图中省略了各模 块之间的界面数据。

![](img/程序设计思想与方法 129930.png)

图 4.8 calendar 程序的第二层结构图

# 4.3.3 第三层设计

### 4.3.3 第三层设计

首先考虑函数 leapyears 的实现，该函数的功能是计算从 1900 到 year（不含）之间 的闰年个数。这可以用逐年检验的方法来实现①：对从 1900 到 year-1 的每一年，测试该 年是否闰年，如果是则为计数变量 count 加 1。于是得到如下代码：

```
def leapyears(year): count = 0
for y in range(1900,year):
    if y%4 == 0 and (y%100 != 0 or y%400 == 0): 
        count = count + 1
    return count 
```

其中 if 语句的布尔表达式是根据闰年的规定得到的：年份能被 4 整除并且不能被 100 整除（除非该年能被 400 整除）。

再考虑函数 heading 的实现，该函数用于打印每个月日历的标题部分（月份和星期名 称）。我们将月份名称放在一个列表中，然后通过传递给 heading 函数的月份值作为索引 来查找月份名称。代码如下：

```
def heading(m):
    months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sept","Oct","Nov","Dec"]
    print " %s " % (months[m]) 
    print "Mon Tue Wed Thu Fri Sat Sun" 
```

> ① 如果从公元 1 年算起，到 year 年为止的闰年个数可用公式 year/4 ? year/100 + year/400 计算。

第三层的最后一个函数是 oneMonth()，其功能是输出一个月的日历。由于日历输出要求在合适的位置上显示合适的日期，这个用于输出的子程序反而是整个程序最费功夫的部 分。为了安排日历布局，需要了解每月 1 日是星期几和每月有多少天，还需要确定何时换行显示。我们采用一个长度为 6×7=42 的列表①作为日历布局框架（每行 7 天，一个月最多占用 6 行），只需将一个月的每一天存入这个框架的合适位置，然后输出这个列表即可。图 4.9 是日历框架的示意图。

![](img/程序设计思想与方法 130850.png)

图 4.9 每个月的日历布局 由于问题有点复杂，我们再次分解任务，用三个子程序来实现 oneMonth()：days() 函数计算该月份的天数，layout()函数用于布置该月每一天在日历框架中的位置 ，printMonth()用于输出日历。即：

```
def oneMonth(year,month,first): 
    d = days(year,month)
    frame = layout(first,d) 
    printMonth(frame)
    return (first + d) % 7 
```

oneMonth 函数有三个参数：year 表示年份，month 表示月份，first 表示该月 1 日是星期几（0～6）。对于一月份，first 由上层模块 printCalendar 的参数 w 提供； 对于其他月份，first 可由上一个月的 first 和天数确定，因此我们让 oneMonth 在打印 本月日历后返回下个月 1 日的星期序号。

> ① 使用二维列表或许会更直观。

设计至此，结构图演变为图 4.10 所示的情况。

![](img/程序设计思想与方法 131330.png)

图 4.10 calendar 程序的第三层结构图

# 4.3.4 第四层设计

### 4.3.4 第四层设计

先考虑 days 函数的实现。我们将每个月的天数放在列表中，然后通过月份进行索引即 可得到该月天数。要注意有个特殊情形，即闰年 2 月份。这时应当为天数多加 1 天。代码如 下：

```
def days(y,m):
    month_days = [31,28,31,30,31,30,31,31,30,31,30,31]
    d = month_days[m]
    if (m == 1) and (y%4 == 0 and (y%100 != 0 or y%400 == 0)): 
        d = d + 1
    return d 
```

接着考虑函数 layout 的实现。本函数根据 first 和 d，将每一个日期填入日历框架（图 4.9）。

```
def layout(first,d): 
    frame = 42 * [""] 
    if first == 0:
        first = 7 
    j = first - 1
    for i in range(1,d+1): 
        frame[j] = i
        j = j + 1 
    return frame 
```

最后实现 printMonth 函数。日历布局已经保存在列表 frame 之中，函数要做的事情就是将列表成员打印出来。其中的关键是掌握好换行的时机，采用了日历框架后这一点变得很简单，只需每输出 frame 的七个成员就换行一次。代码如下：

```
def printMonth(frame): 
    for i in range(42):
        print "%3s" % (frame[i]), 
        if (i+1)%7 == 0:
            print 
```

至此，我们为 calendar 程序设计的所有模块都已实现。

# 4.3.5 自底向上实现与单元测试

### 4.3.5 自底向上实现与单元测试

自顶向下设计设计是创建层次化的模块结构的过程，而从实现的角度看，我们又是采取了相反的过程，即自底向上的实现。从结构图的底层开始实现每一个函数，然后上一层模块 自然得到实现。就这样自底向上，直至主程序得到完全的实现。

在模块化编程中，测试程序最适合采用单元测试技术，即先分别测试每一个小模块，然 后再逐步测试较大的模块，直至最后测试完整程序。以 calendar 程序为例，当我们实现了 days(y,m)函数后，就应该来测试此函数是否能完成预定的功能——返回 y 年 m+1 月有多 少天。我们可以将 days(y,m)的定义存入一个模块文件（假设文件名是 moduletest.py）， 然后导入该文件并测试函数。下面是测试 days 函数的一个会话过程：

```
>>> from moduletest import days
>>> days(1900,0)
31
>>> days(1900,1)
28
>>> days(1900,11)
31
>>> days(2000,1)
29
>>> days(2012,1)
29
>>> days(2012,10)
30 
```

注意，测试时应当使测试数据尽量覆盖所有关键情形。在我们的测试例子中，测试了合 法数据的边界情形 1900 年 1 月，也测试了 1900 年 2 月（这个年份虽然能被 4 整除但却不是闰年），还测试了 2000 年（能被 400 整除）是否闰年。所有测试结果都表明这个函数实现正 确。

单元测试技术独立地测试每一个函数，这样能更容易定位程序错误。如果较小模块都正 确，那么由它们组成的较大模块出现错误的可能性也就较小。最终测试完整程序时，就更有 希望通过测试。

最后，为了完整起见，我们将前面所有的代码汇集起来列在下面。

【程序 4.8】calendar.py

```
# calendar.py
def getYear():
    print "This program prints the calendar of a given year." 
    year = input("Please enter a year (after 1900): ")
    return year
def firstDay(year):
    k = leapyears(year)
    n = (year - 1900) * 365 + k return (n + 1) % 7
def leapyears(year): count = 0
    for y in range(1900,year):
        if y%4 == 0 and (y%100 != 0 or y%400 == 0): 
            count = count + 1
    return count
def printCalendar(year,w): print
    print "=========== " + str(year) + " =========="
    first = w
    for month in range(12):
        heading(month)
        first = oneMonth(year,month,first)
def heading(m):
    months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sept","Oct","Nov","Dec"]
    print " %s " % (months[m]) 
    print "Mon Tue Wed Thu Fri Sat Sun"
def oneMonth(year,month,first): d = days(year,month)
    frame = layout(first,d) 
    printMonth(frame) return (first + d) % 7
def days(y,m):
    month_days = [31,28,31,30,31,30,31,31,30,31,30,31]
    d = month_days[m]
    if (m == 1) and (y%4 == 0 and (y%100 != 0 or y%400 == 0)): 
        d = d + 1
    return d
def layout(first,d): frame = 42 * [""] 
    if first == 0:
        first = 7 
    j = first - 1
    for i in range(1,d+1): 
        frame[j] = i
        j = j + 1 
    return frame
def printMonth(frame): 
    for i in range(42):
        print "%3s" % (frame[i]), 
        if (i+1)%7 == 0:
            print
def main():
    year = getYear()
    w = firstDay(year) 
    printCalendar(year,w)
main() 
```

图 4.11 显示了本程序的一次运行结果，可见程序是正确的（注意 2012 是闰年）。当然， 输出的日历在格式上还可以美化，例如将两三个月的日历放在同一排上之类。读者不妨自行 设计修改。

![](img/程序设计思想与方法 134264.png)

图 4.11 calendar 程序的运行示例

# 4.3.6 开发过程小结

### 4.3.5 开发过程小结

calendar 程序的完整开发过程，展示了自顶向下设计方法的强大能力。当面临一个复杂 问题而感到无从下手的时候，可以尝试将原始问题分解为若干个子问题，然后再去考虑每个 子问题的解决方案。这个分解过程可以重复进行，从结构图的顶层开始，自顶向下逐步求精， 直至得到所有子问题的精确代码。

自顶向下设计过程可以概括为以下四个步骤：

（1）将问题分解为若干子问题；

（2）为每个子问题设计一个函数接口；

（3）将原问题的算法用各子问题对应的函数接口来表达；

（4）对每个子问题重复（1）～（3）的过程。 经过以上步骤，高层的抽象接口在低层逐步得到细化，最终到达可以直接用 Python 基

本语句实现的层次。 自顶向下设计是编写复杂程序的重要工具，虽然这种方法会导致很多小模块（函数），看上去设计起来有点麻烦，但这其实是事半而功倍的方法。事实上不采用模块化方法是不可 能设计出复杂系统的。

模块化设计和单元测试都是分离关注点原则的具体体现，前者使我们能够设计复杂程 序，后者使我们能够调试复杂程序。作为初学者，应当不断地实践模块化方法，让模块化思 想和方法变成自己的本能思维方式。

最后要说明一点，自顶向下设计是非常强大的编程技术，但并非唯一的编程技术，有时 这种设计方法并不可行。例如，自顶向下设计的第一步是对整个系统进行任务分解，然而在 开发某些应用时，可能无法对整个系统的需求先有充分的理解，只能随着开发的进行，逐渐 获得对系统的理解，这时就不可能采用自顶向下设计。

本书后面还会介绍其他程序设计方法，比如原型方法、面向对象设计等等。程序设计是一个创造性的过程，并不存在什么唯一正确的方法或者一成不变的规则。好的开发者应当掌 握多种设计方法。虽然通过读书学习可以了解程序设计技术，但更重要的是通过实践来掌握 在什么场合应用以及如何应用这些方法。

# 4.4 Python 模块*

## 4.4 Python 模块*

模块这个术语通常用于泛指相对独立的程序单元，Python 语言中的模块既有这种一般 含义，还有其特定的含义。

# 4.4.1 模块的创建和使用

### 4.4.1 模块的创建和使用

在 Python 语言中，模块对应于 Python 程序文件，即每个 Python 程序文件就是一个模块。 模块是 Python 程序的最高层结构单元，用于组织程序的代码和数据，以便能被同一程

序的其他模块甚至被其他程序重用。一个模块可以导入其他模块，导入后就可以使用其他模 块中定义的函数、类等对象。

用模块作为程序的结构单元，至少有三个作用：

（1）代码重用：将代码保存在能持久存在的文件中，就不会像在 Python 交互环境中键 入的代码那样随着退出 Python 而消失。模块中的代码可以多次加载运行，也可以被多个程 序使用。

（2）名字空间：模块是 Python 的最高层程序结构单元，在模块中定义的所有名字（函 数名、类名等）是局部于本模块的，与模块外部不会发生同名冲突。要想使用一个模块定义 的名字，唯一途径就是导入该模块。

（3）实现共享：模块对于实现全系统范围内代码和数据的共享也是很有用的，被共享 的东西只需保存一个副本。例如，如果需要为多个函数或模块提供一个全局对象，则可以将 它的定义置于一个模块中，然后其他使用者可以导入该模块，从而共享使用全局对象。

Python 模块很容易创建。只要使用任意的文本编辑器，键入一些 Python 语句并保存 为.py 文件，就得到一个 Python 模块。

为了使用 Python 模块中定义的对象，必须用 import 或 from 语句导入模块。import 的功能是导入模块整体，导入后为了访问模块定义的对象，必须在对象前加上模块名作为前 缀。例如，假设模块 mymod 中定义了我们需要用到的函数 func()，那么可以这样导入：

```
import mymod mymod.func() 
```

另一种导入语句是 from 语句，用于导入模块中定义的特定名字（用*可以导入所有名字）。使用时不需要加上模块名作为限制。例如：

```
from mymod import func func() 
```

注意，导入模块后，模块名就能像普通 Python 变量一样在程序中使用。因此模块名必须符合 Python 命名规则。

# 4.4.2 Python 程序架构

### 4.4.2 Python 程序架构

简单程序可以只用一个程序文件实现，但对绝大多数 Python 程序，一般都是由多个源 文件（即模块）组成的，其中每个源文件都是包含 Python 语句的文本文件。

具体来说，Python 程序通常是由一个顶层主文件和多个模块文件组成的。顶层主文件 定义了程序的主控制流，是执行应用程序时的启动文件；模块文件则是“工具”库，用于汇 集顶层文件和其他模块需要用到的函数等部件。顶层文件使用模块文件中定义的工具来完成 应用功能，同时一个模块也可使用别的模块定义的工具。

模块文件一般不能直接执行，模块中只是定义了很多工具给其他模块使用。Python 中 通过导入模块来使用该模块定义的工具。图 4.12 描绘了一个由三个文件（a.py、b.py 和 c.py）组成的 Python 程序，其中 a.py 是顶层文件，b.py 和 c.py 是模块。b.py 和 c.py 一般不能直接执行，该程序的执行只能通过 a.py 来启动。

![](img/程序设计思想与方法 136477.png)

图 4.12 Python 程序架构

假设文件 b.py 中定义了一个函数 hello 给外部使用：

```
def hello(person):
    print "Hello", person 
```

再假设 a.py 正好需要使用 hello()，为此可以在 a.py 中导入模块 b，然后调用 hello()：

```
import b
b.hello("Lucy"') 
```

其中的导入语句使得 a.py 能够访问 b.py 中顶层代码所定义的所有名字（这里只有 hello）。a.py 的第二条语句调用模块 b 中定义的函数 hello，其中 b.hello()这种“点 表示法”其实是面向对象的表示法，b 是一个模块对象，hello 则相当于 b 对象的一个属 性。b.hello 就等于说“对象 b 中的属性 hello 的值”，这个值恰好是一个可调用的函数， 因此可以传递一个字符串参数"Lucy"'给它。

任何模块文件都可以从任何其他模块文件导入定义，例如文件 a.py 可导入 b.py， b.py 也可以导入 c.py。导入链条可以任意深入下去：a 导入 b，b 导入 c，c 导入 b，等 等。

除了作为最高层结构单元，模块还是代码重用的最高层形式。例如，如果很多模块都需 要使用函数 b.hello，那我们可以在别处导入 b.py，从而达到代码重用的目的。

# 4.4.3 标准库模块

### 4.4.3 标准库模块

应用程序要导入的模块大多来自 Python 语言提供的标准库。Python 标准库实现了很多 常见功能（如操作系统功能、GUI 构建、网络与互联网编程等），对应用程序设计提供了强 大的支持。标准库并不是 Python 语言本身的一部分，而是由专业程序员预先编好并随语言 提供给用户使用的。Python 的标准安装都会自动安装标准库。

如果想了解随着 Python 安装的标准库中有哪些模块，可以使用 Python 的联机帮助命令。 在 Python 解释器提示符下键入 help()，可以进入联机帮助环境：

```
>>> help()
Welcome to Python 2.7! This is the online help utility.
......
help> 
```

省略号是 Python 打印的一些说明信息。help>是帮助系统的提示符，可以在这个提示符下 输入想了解的主题，Python 就会给出有关主题的信息。例如输入 modules 可以得到安装的 所有模块的信息：

```
help> modules
Please wait a moment while I gather a list of all available modules... AppClass1 asynchat ftplib roller
......
help> 
```

输入某个模块的名字可以获得该模块的信息，例如：

```
help> math
Help on built-in module math:
NAME
math
FILE
(built-in)
DESCRIPTION
This module is always available. It provides access to the mathematical functions defined by the C standard.
FUNCTIONS
acos(...)
acos(x)
Return the arc cosine (measured in radians) of x. 
```

从系统显示的信息中我们了解到 math 模块中 acos 函数的意义和用法。

在 Python 中，要想编写有用的或有趣的应用程序，往往并不需要自己写很多代码，标

准库中有大量的现成代码可用。读者需要时可自行查阅有关 Python 标准模块的资料，以求 事半功倍。

# 4.4.4 模块的有条件执行

### 4.4.4 模块的有条件执行

有些 Python 模块是可以直接执行的，一般称为程序或脚本；而另一些 Python 模块中只 包含一些函数定义，本身并没有主程序入口，因而不能执行。标准库就属于后一种模块。有 时我们希望创建一种混合式的模块——既可以作为独立执行的程序，又可以作为被其他程序

导入的库。在 Python 中，混合式模块可以通过在程序入口前加上特定条件而实现。 如所熟知，我们一般都在程序文件的最后加上启动程序的一行语句：

```
main() 
```

这是对程序入口（主函数 main）的调用，没有这一行，程序文件就不是可执行的文件。这 就是直接执行的模块文件，在窗口系统中用鼠标双击即可启动程序。

Python 在导入一个模块的时候会执行模块中的每一行语句，执行函数定义语句 def 时 就创建相应的函数但并不执行，而最后遇到启动程序的 main 时就启动了整个程序。有时我 们希望导入模块时不要执行整个程序，例如交互环境下测试程序时，通常的做法是先导入模 块，需要执行代码时才去调用 main 或其他函数。要想只导入不执行，当然可以删掉程序入 口 main()，但这又会失去双击执行程序的可能。两全其美的做法是在主程序入口 main 之 前加个条件：

```
if <条件>:
    main() 
```

意思是当条件满足时启动程序，否则不启动程序。问题是条件怎么写？

如果是用 import 导入模块，Python 会将该模块的一个特殊变量 name 的值设置为 模块的名字。例如：

```
>>> import math
>>> print math.__name__
math 
```

第一行导入模块 math，并将 math 的变量 **name** 设置为'math'。第二行显示了这个变量的值。

但如果是直接执行模块（如双击模块文件图标等），Python 则将模块的特殊变 量 name 设置为字符串'main'。因此可以通过特殊变量 name 的值来判断模块是被 导入的还是被直接执行的。根据这个底层细节，我们可以将程序文件的最后一行改成：

```
if __name__ == ’__main__’:
    main() 
```

这样就能确保当程序是直接执行时，main 能启动；当程序是被导入时，忽略 main。

# 4.5 练习

## 4.5 练习

1\. 什么是模块化设计？

2\. 模块有哪些特点？

3\. 什么是分离关注点原则？

4\. 子程序的创建和调用涉及哪些内容？

5\. 程序中为什么引入函数？

6\. 什么是形式参数和实际参数？参数传递的过程是怎样的？

7\. 什么是变量的作用域？什么是全局变量与局部变量？

8\. 函数的参数与局部变量的异同是什么？

9\. 函数调用时的控制流是如何转移的？

10\. 什么是自顶向下设计？主要分为哪几个步骤？

11\. 为具有下列主函数的程序画出结构图的顶层。

```
def main():
    printIntro()
    length, width = getDimensions() 
    amtNeeded = computeAmount(length,width)
    printReport(length, width, amtNeeded) 
```

12\. 请写出五个 Python 标准库中的模块名称及其主要功能。

13\. 考虑函数：

```
def cube(x):
    answer = x * x * x 
    return answer 
```

（1）这个函数的功能是什么？

（2）设 y 是一个变量，如何用 cube 函数去计算 y3？

（3）考虑下面这个程序片段：

```
answer = 4 
result = cube(3)
print answer, result 
```

由于 cube 将 answer 赋值成了 27，所以输出应该是 27 27，对不对？为什么？

14\. 设计程序：在屏幕上打印歌曲《歌唱祖国》的歌词①。

15\. 设计程序：给定两个平面上的点 p1 和 p2（用元组表示），函数 slope(p1, p2)返回 通过 p1 和 p2 的直线的斜率，函数 intercept(p1, p2)返回该直线在 y 轴上的截距。

16 改写本章中的 calendar 程序，使输出更美观（例如让每三个月的日历输出在同一排上）。

17\. 采用自顶向下设计方法编写程序：在屏幕上打印三角函数 y = sin(x)的图像。

18\. 重做第三章的程序设计练习题，尽量使用函数来封装计算。

> ① 歌词参见 [`baike.baidu.com/view/252108.htm`](http://baike.baidu.com/view/252108.htm)