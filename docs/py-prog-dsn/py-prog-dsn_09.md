# 第八章 图形用户界面

# 第八章 图形用户界面

随着 Windows 之类的图形化操作系统的产生和发展，如今用户在与计算机打交道时基本 上都使用形象直观、简单易学的图形化方式，即通过鼠标点击菜单、命令按钮等图形化元素 来向应用程序发出命令，而应用程序也以消息框、对话框等图形化元素来向用户显示各种信 息。因此，为程序建立图形化的用户界面已经成为当今程序设计必备的基本技术之一。本章 介绍图形用户界面的设计和实现，具体内容包括图形构件的用法、Python 标准 GUI 工具包 Tkinter、事件驱动编程以及模型－视图(MV)设计方法。

# 8.1 图形用户界面概述

## 8.1 图形用户界面概述

# 8.1.1 程序的用户界面

### 8.1.1 程序的用户界面

界面是指两个体系之间的分界与接合部分，例如人－机界面、水－油界面等。在程序设计领域，一个程序的用户界面（user interface，简称 UI）指的是程序中与用户进行交互的部 分，用户通过 UI 向程序输入数据或者请求程序执行特定任务，而程序通过 UI 向用户显示各 种信息。

如果程序员写的程序是自用的，那么用户界面是怎样的并不重要，因为程序员完全了解 程序的行为，能够以最直接的方式来控制程序的运行。但实际上程序员往往是在为其他用户 写应用程序，而用户并不了解程序的内部行为，甚至对计算机技术也可能只是一知半解，因 此程序员必须为应用程序设计用户友好的（user friendly）界面，以便用户能很好地与应用程 序交互。所谓“用户友好”并没有严格的定义，大体指界面易学易记，用户能够高效率地与 计算机进行交互，交互过程中不易犯错，即使犯错也容易恢复。

在本章之前，我们写的程序都是所谓控制台程序，这种程序一般只提供命令行界面（Command Line Interface，简称 CLI），即用户通过键盘输入文本数据或文本命令来控制程序 的行为，而程序向用户显示的也都是文本信息。

与命令行界面不同，图形用户界面（Graphical User Interface，简称 GUI①）提供图形化 界面来实现程序与用户的交互。在 GUI 中，用户通过直接操作窗口、菜单、按钮等图形元素 来向程序发出命令或输入数据，而程序通过消息框、对话框等图形元素来向用户显示信息。 由于图形界面非常直观、易理解，所以 GUI 使得只具有一点基本计算机技能的用户也能顺利 地与计算机打交道。

作为例子，图 8.1 展示了读者已经熟悉的两种界面的 Python 解释器程序：命令行界面和 GUI（即 IDLE）。相信读者已经体会到 IDLE 在编辑源代码、运行和调试程序时的便利和高 效。

![](img/程序设计思想与方法 236737.png)

![](img/程序设计思想与方法 236738.png)

图 8.1 Python 解释器的两种用户界面

> ① GUI 可读作[gu:i]。

通过操作系统的演化史也可以清楚地了解两种界面的优劣。操作系统是计算机上最重要 的系统软件，用户通过操作系统提供的命令来使用计算机。早期的计算机都使用命令行界面 的操作系统，典型的如 DOS 和 UNIX。用过 DOS 的人都知道，为了让计算机做事情，需要 记忆很多 DOS 命令。例如为了将文件 myfile.txt 从 d:\拷贝到 d:\mydir 目录中，需要输入如下 命令：

```
C:\> copy d:\myfile.txt d:\mydir 
```

为了让计算机更加易用，后来人们发明了图形界面的操作系统，典型的如 Microsoft Windows 和 X Window。在 Windows 中要想做上面这条 DOS 命令所做的事情，根本不需要键 盘，只需用鼠标点击几下进行复制粘贴，甚至直接拖动文件到新的文件夹即可。自从有了 Windows，今天的计算机用户可能都不知道曾经有 DOS 这样的东西了。

总之，GUI 能够大大增强程序的用户友好性，提高用户使用计算机的效率，因此是程序 设计中的重要技术。

# 8.1.2 图形界面的组成

### 8.1.2 图形界面的组成

应用程序的图形界面是由底层操作系统支持的，不同操作系统平台的图形界面风格不尽相同，但组成界面的图形元素都是类似的。下面我们采用 Python 的标准图形界面工具包 Tkinter 的术语来介绍图形界面元素。 图形界面由多种图形元素组成，这些图形元素称为构件（widget）①。就如一部机器由各种零部件组成一样，图形界面这部“机器”的零部件就是构件。从程序角度看，每个构件都 表示了程序的某个数据并提供了对此数据的操作。用户与构件进行交互，从而使用或控制程 序的某个数据。设计 GUI 时，程序员的任务就是合理地利用各种构件，将它们搭配组合起来，， 目标是提高用户与应用程序的交互效率。

窗口（window）可能是读者最熟悉的一种 GUI 构件了②，它是一个由程序控制的矩形屏 幕区域，在此区域中可以放置其他构件。像窗口这样的能够容纳其他构件的构件，一般称为 容器（container）。对于窗口，用户常做的操作是移动、改变大小等。每个 Tkinter 程序都必 须创建一个最外层的窗口，称为根窗口。

在窗口中通常会布置许多用于与用户进行交互的构件，如标签（label）、按钮（button）、 菜单（menu）等等。这些构件是基本界面元素，它们不再包含其他构件。每种构件都有各自 的用途，例如接受用户输入、执行命令、显示信息等。

如果窗口中包含的构件很多，布置不当的话会使界面杂乱无章，降低界面的易用性。这 时可以用框架（frame）构件来分隔窗口空间和组合构件，以使界面结构清晰。框架也是矩形 屏幕区域，通常用作容器，是建立多级结构的图形界面的基本组织工具。例如，图 8.2 显示 的窗口中用到两个框架和两个按钮，框架 F1 中包含两个勾选钮。

> ① 别的系统也有称为控件或组件的。
> 
> ② 微软公司的图形化操作系统干脆以 Windows 命名。

![](img/8-2.png)

图 8.2 多级结构的界面

窗口或框架是容器构件，能够包含其他构件，由此可见构件之间存在着一种层次关系， 称为父子关系。在图 8.2 中，窗口 W 包含框架 F1 等构件，我们称 W 是 F1 等构件的父构件， F1 等都是 W 的子构件。同样，F1 又包含勾选钮 C1 和 C2，故 F1 是 C1 和 C2 的父构件，C1 和 C2 是 F1 的子构件。设计 GUI 时，必须明确指出构件之间的父子关系。仍以图 8.2 为例： 创建 F1 时必须指明是在 W 中创建，创建 C1 时必须指明是在 F1 中创建。

按照构件之间的父子关系，一个图形界面中的所有构件形成了一个树状层次结构，该层 次结构的最高层是根窗口。任何构件（根窗口除外）必有唯一的父构件，还可能有若干子构 件。

在父构件（窗口或框架）中如何安排子构件的位置？这属于图形界面的布局问题，GUI 工具包一般提供布局管理器（layout manager 或 geometry manager）用于布局设计。Tkinter 提供了 Pack、Grid 和 Place 等三种布局管理器，使得在容器中布置子构件的任务轻而易举。

# 8.1.3 事件驱动

### 8.1.3 事件驱动

图形构件组成了图形界面的可见部分，在这些可见构件的背后，还有不可见的程序逻辑。 就好比家用电器都提供操作面板，用户通过操作面板控制、使用电器功能，在面板的背后是 实现功能的电路逻辑。

GUI 应用程序的特点是注重与用户的交互，因此程序的执行取决于与用户的实时交互情 况。例如 Word 程序启动后，并非一路执行到程序结束，而是在做了必要的初始化工作后就 停下来，等待用户的下一步动作。用户可能在文档窗口中输入文本，也可能通过菜单设置选 项，还可能点击工具栏里的存盘图标，总之是完全不确定的。Word 程序只能等到用户的交互 动作发生后，才去执行相应的处理代码。

由于 GUI 程序的执行流程由用户控制，并且不可预期，为了适应这种特点，我们需要采 用事件驱动的编程方法。普通程序的执行可概括为“启动——做事——终止”，而事件驱动的 程序的执行可概括为“启动——事件循环（即等待事件发生并处理之）”。作为特例，GUI 程 序的终止也是由特定事件（如关闭窗口事件）引起的。

事件（event）是针对应用程序所发生的事情，并且应用程序需要对这种事情做出响应。 程序对事件的响应其实就是调用预先编制好的代码来对事件进行处理，这种代码称为事件处 理程序（event handler）。GUI 中最常见的事件是用户的交互动作，如按下某个键或者点击鼠 标。当然在其他类型的应用程序中也会出现其他类型的事件，例如在各种监控系统中，传感 器采集环境数据并传给程序，就可视为发生了需要处理的事件。又如在面向对象程序中，向 某个对象发送消息，也可看成是发生了某种需要响应的事件。事件驱动编程（event-driven programming）就是针对这种“程序的执行由事件决定”的应用的一种编程范型。

事件驱动的程序一般都有一个主循环（main loop）或称事件循环，该循环不停地做两件 事：事件监测和事件处理。首先要监测是否发生了事件，如果有事件发生则调用相应的事件 处理程序，处理完毕再继续监测新事件。那么，主循环如何监测事件以及如何触发相应的事 件处理程序呢？这个问题牵涉到操作系统的低层机制，比较复杂。好在这部分代码是独立于 具体应用程序的，一般都由 GUI 工具包提供支持，应用程序员只需编写自己的事件处理程序。

# 8.2 GUI 编程

## 8.2 GUI 编程

# 8.2.1 UI 编程概述

### 8.2.1 UI 编程概述

编写 GUI 程序与编写控制台程序既有相似点，又有一些差别。一方面，任何程序都要利 用编程语言的顺序、循环、分支、函数、模块等成分来搭建程序总体结构、控制程序流程；

另一方面，控制台程序要实现的功能一般都没有现成代码，需要程序员自己编制，而 GUI 程 序中的界面设计有 GUI 工具包支持，程序员的编程工作可以大大减少。这是因为图形界面在 技术上涉及很多底层细节，在功能上又具有与特定应用无关的通用性，所以很适合由专业的 软件厂商来实现，并以工具包的形式提供给程序员使用。

针对不同的操作系统平台、不同的编程语言，存在不同的 GUI 工具包。每种工具包都有 自己的编程界面和程序设计模式，程序员必须学习并遵循这些模式。有些工具包可以运行在 多种操作系统（如 Windows，Unix，MacOS）之上，并能在多种编程语言中使用，称为跨平 台的工具包。程序员一般都固定使用某种跨平台工具包，而不是换个平台就换个工具包，因 为学习使用一个新的工具包可能比学习一个新的编程语言还要难！

本书使用 Python 语言提供的标准 GUI 工具包：Tkinter 模块①。这个模块的名称来历是这 样的：原先有一种流行的跨平台 GUI 工具包 Tk，现在 Tkinter 模块通过定义一些类和函数， 实现了一个在 Python 中使用 Tk 的编程接口。可以简单地说，Tkinter 就是 Python 版的 Tk。

GUI 编程一般需要如下几个步骤：

1.  设计界面外观：这包括创建窗口和其他各种构件，并进行合适的布局。这一步与其 说是程序设计，不如说是美工设计。在流行的 Visual Basic、Eclipse 等集成开发环境 中，这一步只需用鼠标点击、拖放、调整大小就能完成。

2.  为每个构件定义事件处理程序：这一步是 GUI 开发的核心任务，决定着程序的功能 和与用户交互时的行为。

3.  编写应用程序的启动和总控部分：进行必要的初始化工作之后，进入主循环。 不同应用程序的用户界面虽然肯定会有不同，但构件的选择和布局是有很多共性的。读者如果用过一些 Windows 应用程序（如 MS Office 中的各种程序）的话，一定会发现众多 Windows 程序在界面风格方面的雷同。以下我们虽然用 Tkinter 来实现 GUI，但各种构件的 用法和布局的讨论是有普遍意义的。

GUI 工具包一般都利用面向对象技术实现的，即构件都是对象，具有属性和方法。构件 对象的属性用来记录构件的各种数据特性，构件对象的方法实现构件的行为特性。

# 8.2.2 初识 Tkinter

### 8.2.2 初识 Tkinter

Tkinter 模块中定义了许多构件类，利用这些构件类可以容易地创建构件实例，从而建立 图形界面。下面按字母顺序列出一些常用的构件类及其简要功能：

*   Button：按钮。用于执行命令。

*   Canvas：画布。用于绘图、定制构件。

*   Checkbutton：勾选钮。用于表示是否选择某个选项。

*   Entry：录入框。用于输入、编辑一行文本。

*   Frame：框架。是容器构件，用于构件组合与界面布局。

*   Label：标签。用于显示说明文字。

*   Listbox：列表框。用于显示若干选项。

*   Menu：菜单。用于创建下拉式菜单或弹出式菜单。

*   Message：消息。类似标签，但可显示多行文本。

*   Radiobutton：单选钮。用于从多个冲突选项中选择一个。

*   Scrollbar：滚动条。用于滚动显示更多内容。

*   Text：文本区。用于显示和编辑多行文本，支持嵌入图像。

*   Toplevel：顶层窗口。是容器构件，用于多窗口应用程序。

> ① 其他常用的 GUI 工具包有 wxPython，PyQt 等。

为了使用 Tkinter 中定义的构件类，需要先导入 Tkinter 模块。下面两种形式的 import 语 句都可以，一般来说后一种形式更方便。

```
import Tkinter
from Tkinter import * 
```

首先看一个最简单的 Tkinter 程序：

【程序 8.1】eg8_1.py

```
from Tkinter import * 
root = Tk() 
root.mainloop() 
```

程序 8.1 的第 1 行导入 Tkinter 模块。第 2 行调用 Tk 构造器，初始化 Tk 并自动创建一个 根窗口。根窗口的形状依赖于操作系统平台，一般都具有标题栏和最小化、最大化、关闭按 钮。每个程序必须有也只有一个根窗口，并且要先于其他构件创建①，其他构件都是根窗口 的子构件。第 3 行进入主循环，准备处理事件。除非用户关闭窗口，否则程序将一直处于主

循环中。注意：只有进入了主循环，根窗口才可见②。程序的执行结果如图 8.3 所示：

![](img/程序设计思想与方法 241500.png)

图 8.3 程序 8.1 的执行结果

程序 8.1 只搭建了一个图形界面雏形，除了根窗口，界面中没有任何能与用户进行交互 的构件。下面这个程序略有改进，在窗口中添加了一个标签构件：

【程序 8.2】eg8_2.py

```
from Tkinter import * 
root = Tk()
aLabel = Label(root, text="Hello World") 
aLabel.pack()
root.mainloop() 
```

程序 8.2 的第 3 行创建标签构件 aLabel，Label 构造器的第一个参数 root 表示该标签构件 是根窗口的子构件，第二个参数指定标签的文本内容。第 4 行表示用 Pack 布局管理器对标签 构件进行布局，这使得标签在根窗口中以紧凑的方式摆放。程序的执行效果如图 8.4 所示：

![](img/程序设计思想与方法 241918.png)

![](img/程序设计思想与方法 241920.png)

图 8.4 程序 8.2 的执行结果

大多数构件在创建之后并不会立即显示在窗口中，必须经由布局管理器进行布置之后才变成可见的，因此多数构件都要像上例中的标签构件一样经历创建和布局两个步骤。

> ① 事实上，如果程序没有显式创建根窗口而直接去创建其他构件，系统仍然会自动创建根窗口。
> 
> ② 如果在命令行环境中交互式执行程序语句，窗口和其他构件无需进入主循环就能显示。

构件对象属性

每个构件都是对象，构造对象时设置的各种参数都是对象的属性（实例变量），如上例中 标签构件的 text 属性。Tkinter 构件一般都有许多属性，在用构造器创建构件实例时可以为一 些属性设置属性值，而没有设置的属性也都有预定义的缺省值。由于属性众多，又是有选择 地设置，所以创建实例时适合采用“命名参数”方式来传递属性值，即“属性=属性值”的 形式①。属性值如果是数值或单个字符，可以不用引号；如果是数值与字母混用，或者是字 符串，则必须用引号。

构件对象的属性值既可以在创建时指定，也可以在将来任何时候设置或修改。每种构件 类都提供 configure（或简写为 config）方法用于修改属性值。例如，如果在程序 8.2 中倒数 第 2 行处增加一条语句：

```
aLabel.config(text="Goodbye") 
```

则执行程序后就会看到标签文本从“Hello World”变成了“Goodbye”。

Tkinter 还提供了另一种修改构件对象属性值的方法：将对象视为一个字典②，该字典以 属性名作为键，以属性值作为键值。按照修改字典键值的语法，上面这条语句可以写成：

```
aLabel["text"] = "Goodby" 
```

用字典方法每次只能修改一个属性的值，而用 config 每次可以修改多个属性的值，例如 下面这条语句同时修改了标签的文本、前景色和背景色：

```
aLabel.config(text="Goodbye",fg="red",bg="blue") 
```

根窗口的标题和大小

从图 8.3 和图 8.4 可见，根窗口默认的窗口标题是 Tk，如果对此不满意，可以通过调用 根窗口对象的 title 方法来设置窗口标题：

```
root.title("My GUI") 
```

根窗口的默认大小是宽度和高度各为 200 像素，如果对此不满意，可以通过调用根窗口 对象的 geometry 方法来设置窗口大小。指定窗口尺寸的最简单形式是“宽度 x 高度”：

```
root.geometry("400x400") 
```

父构件与子构件

如前所述，图形界面中的所有构件按父子关系构成了树状层次，构件之间的父子信息记录在每个构件都有的 master 和 children 属性中，Tkinter 会自动维护这两个属性的值。编程时， 可以利用这两个属性来从子构件找到其父构件，从而间接引用父构件。例如语句

```
aLabel.master.title("My GUI") 
```

的意思是对标签构件 aLabel 的父构件（即 root）调用 title 方法来设置窗口标题。

图形界面中当然不会只有一个构件，仿照上面创建标签构件的过程，我们可以根据需要 创建多个构件并在窗口中布局，最终设计出复杂的图形界面。例如：

【程序 8.3】eg8_3.py

```
from Tkinter import * 
root = Tk()
aLabel = Label(root,text="Hello World")
aLabel.pack()
aButton = Button(root,text="Click Me") 
aButton.pack()
root.mainloop() 
```

> ① 参见第四章关于函数参数传递的内容。
> 
> ② 回顾第六章关于字典类型的介绍：字典就是“键－值”配对的集合。

程序 8.3 的第 3－6 行分别创建了一个标签和一个按钮构件，并在窗口中用 Pack 布局管 理器进行布局。执行结果如图 8.5 所示：

![](img/程序设计思想与方法 243498.png)

图 8.5 程序 8.3 的执行结果 通过以上几个简单例子可以看出，基于 Tkinter 的图形界面设计非常简单，可概括为创建

构件并在窗口中进行布局的过程。接下来我们就要具体学习各种图形构件的使用方法和布局 方法。

# 8.2.3 常见 GUI 构件的用法

### 8.2.3 常见 GUI 构件的用法

本节介绍一些最常见的 GUI 构件的用法。为了便于讨论，我们使用 Python 的命令行界 面①来交互式地执行语句，这样可以执行一条语句就立即看到其执行效果。读者也可以一边 阅读本书，一边在计算机上动手练习。

GUI 编程首先要做的是导入 Tkinter 模块并创建根窗口：

```
from Tkinter import * 
root = Tk() 
```

可以看到，屏幕上立即出现一个根窗口，接下去就可以向根窗口中加入子构件了。

当所有构件添加完毕，通过执行下列语句来启动主循环：

```
root.mainloop() 
```

这时可以看到 Python 命令行界面的>>>提示符没有了，表明现在 Tkinter 程序接管了控制权。 当最后关闭根窗口时，所有构件也都同时撤销。 下面演示各种构件的用法时，我们既可以在同一个根窗口中演示多个构件的用法，也可以每次演示新构件时重新创建根窗口。由于这两种做法并不影响本节的主旨，为了行文简洁， 我们对此不加区别，以上这几个导入模块、创建根窗口和进入主循环的步骤也不重复列出， 读者练习时可根据需要补上有关步骤。

标签

标签用于在窗口中显示文本信息，Tkinter 定义了类 Label 来支持标签构件的创建。创建 标签时需要指定父构件和文本内容，前者由 Label 构造器的第一个参数指定，后者用属性 text 指定。例如前面已经见过的：

```
>>> aLabel = Label(root,text="Hello World") 
```

这条语句创建了一个标签构件实例，但该构件在窗口中仍然不可见。为使构件在窗口中 可见，需要调用布局管理器对该构件进行位置安排。仍然如前面已经见过的，下面这条语句 对标签对象 aLabel 调用方法 pack，意为用 Pack 布局管理器来安排这个标签的位置：

> ① Python 的 GUI 环境 IDLE 本身是用 Tkinter 写的程序，因此无法在 IDLE 中交互式地创建 Tkinter 窗口和其 他构件。

```
>>> aLabel.pack() 
```

于是标签在根窗口中得到显示，同时根窗口的大小也改变了——变成刚好可以放置新加入的 标签构件（参见图 8.4）。这正是 Pack（“打包”）的效果，即所有东西以紧凑的方式布置。Pack 布局管理器简单易用，但不适合进行复杂布局，我们后面会介绍其他布局管理器。

标签构件除了 text 属性之外，还有其他许多属性。上例中只为标签的 text 属性提供了值 “Hello World”，其他属性（如字体、颜色等）都使用缺省值。下面这条语句为标签的更多属 性设置属性值：

```
>>> Label(root,text='Text in Red',fg='red',width=40).pack() 
```

其中属性 fg 和 width 分别表示标签文本的颜色和标签的宽度，效果见图 8.6：

![](img/程序设计思想与方法 244844.png)

图 8.6 标签构件

注意，上面这条语句采用了将对象创建和对象方法调用结合在一起的语法①：先用构造器 Label(…)创建一个标签对象，然后直接对这个对象调用方法 pack()，而不是先定义一个变 量作为新建对象的引用，然后通过变量引用来调用对象方法。显然，对象创建与对象方法调 用合并的写法不适合需要多次引用一个对象的场合。另外，初学者容易犯的一个错误是写成：

```
w = Label(...).pack() 
```

这条语句实际上是将 pack 的返回结果（None）赋值给 w，而非 Label(…)的返回结果（新建 的标签对象）。为了避免这类微妙的错误，最好将创建构件和构件布局的语句分开。

如果希望在程序运行过程中改变标签的文本内容，可以利用 8.2.2 中介绍的设置构件对象 属性的方法来重新设置标签对象的 text 属性值。很多 GUI 应用程序的窗口底部都有一个状态 栏（例如 Word 窗口的状态栏），用来显示程序的一些状态信息，这可以用标签构件来实现， 状态的变化可以通过修改标签对象的 text 属性值来实现。

按钮

按钮也叫命令按钮，是界面中的一个矩形区域（通常长度大于高度），矩形内部是描述性 的标题(例如常见的“确认”和“取消”)。对按钮的操作是用鼠标点击，其作用是命令程序 去执行预定义的操作。按钮可以说是图形界面中最常见的构件，是用户命令程序执行某项任 务的基本手段。

下列语句在根窗口 root 中创建了一个按钮构件：

```
>>> quitButton = Button(root,text="Quit",command=root.quit) 
```

对按钮构件来说是最重要的属性是 command，它用于将按钮与某个函数或方法进行关 联。传递给 command 的值是一个函数（或方法），该函数就是点击按钮时要执行的操作。上 例中将按钮与根窗口 root 的内建方法 quit 相关联，其功能是退出主循环。注意，传递给 command 属性的是函数对象，函数名后不能加括号，切记 f 是函数对象，而 f()是函数调用（的 结果）。

按钮构件在窗口中的位置也需要用布局管理器来安排，例如用 pack 布局管理器：

```
>>> quitButton.pack() 
```

从显示结果（图 8.7）可以看到，与前述标签的情形一样，quitButton 按钮在窗口中以紧凑方 式布置并变得可见。由于 pack 方法是在 Tkinter 的基类中定义的，而所有构件都是这个基类 的子类，从而都继承了这个方法，所以对标签和按钮以及其他各种构件都可以调用 pack 方法。

> ① 参见第七章。

![](img/程序设计思想与方法 245989.png)

图 8.7 按钮构件

为了验证按钮的功能，我们先进入主循环：

```
>>> root.mainloop() 
```

然后点击 Quit 按钮，可以看到又回到了 Python 解释器的提示符状态，这就是 root.quit 方法 的作用。

实际应用程序中通常由程序员自己定义与按钮相关联的函数，以实现某种操作。下面这 个例子为按钮定义了一个简单的显示信息的函数：

```
>>> def hiButton():
...     print 'hi there'
...
>>> Button(root,text='print',command=hiButton).pack() 
```

如果点击按钮，会看到在控制台显示信息“hi there”。 按钮构件还有其他许多属性，如宽度、文本颜色、按钮边框的 3D 风格、活动状态等等，

更多细节可参看本章后面的附录。

勾选钮

勾选钮也称为勾选框或复选框，用于向用户提供一个选项，用户对该选项有“选中”或 “不选”两种选择。勾选钮在外观上由一个小方框和一个相邻的描述性标题组成，未选中时 方框为空白，选中时方框中出现勾号，再次选择一个已打勾的勾选钮将取消选择。对勾选钮 的选择操作一般是用鼠标点击小方框或标题。Tkinter 的类 Checkbutton 实现了勾选钮构件， 其最简单的用法如下：

```
>>> Checkbutton(root,text="A Choice").pack() 
```

如果程序中需要查询和设置选项的状态，可以将勾选钮与一个控制变量关联。控制变量 是 IntVar 类的实例，值为 1 或 0，分别对应选中和未选中状态。用法如下：

```
>>> v = IntVar()
>>> Checkbutton(root,text="A Choice",variable=v).pack() 
```

程序中可以通过 v.get()和 v.set()来查询或设置勾选钮的状态。 在实际应用中，通常将多个勾选钮组合为一组，为用户提供多个相关的选项，用户可以选中 0 个、1 个或多个选项。例如：

```
>>> Checkbutton(root,text="Math").pack()
>>> Checkbutton(root,text="Python").pack()
>>> Checkbutton(root,text="English").pack() 
```

执行效果如图 8.8 所示。为了在程序中获得各勾选钮的状态，可以为每个勾选钮关联一个不 同的控制变量。

![](img/程序设计思想与方法 247021.png)

图 8.8 勾选钮构件

图 8.8 中各勾选钮排列的不太美观，这是因为 pack 在布局时默认采用了居中对齐方式。 布局管理器提供了其他对齐方式，详见 8.2.4。此外，在实际 GUI 设计中，为了表示一组勾 选钮的相关性，通常会用一个框架容器将它们组合起来（参见图 8.11）。

单选钮

和勾选钮类似，单选钮也是列出选项供用户选择，并且通常也是由若干个单选钮构成一 组来提供多个相关的选项。但与勾选钮不同的是，同组的单选钮在任意时刻只能有一个被选 中；每当换选其他单选钮时，原先选中的单选钮即被取消①。

单选钮的外观是一个小圆框加上相邻的描述性标题，未选中时圆框内是空白，选中时圆 框中出现一个圆点。对单选钮的选择操作是用鼠标点击小圆框或标题。Tkinter 提供的 Radiobutton 类可支持单选钮的创建。例如最简单的单选钮可用如下语句创建：

```
>>> Radiobutton(root,text="One").pack() 
```

如上所述，实际应用中都是将若干个相关的单选钮组合成一个组，使得每次只能有一个 单选钮被选中。为了实现单选钮的组合，可以先创建一个 IntVar 或 StringVar 类型的控制变量， 然后将同组的每个单选钮的 variable 属性都设置成该控制变量。由于多个单选钮共享一个控 制变量，而控制变量每次只能取一个值，所以选中一个单选钮就会导致取消另一个。

为了在程序中获取当前被选中的单选钮的信息，可以为同组中的每个单选钮设置 value 属性的值。这样，当选中一个单选钮时，控制变量即被设置为它的 value 值，程序中即可通 过控制变量的当前值来判断是哪个单选钮被选中了。还要注意，value 属性的值应当与控制变 量的类型匹配：如果控制变量是 IntVar 类型，则应为每个单选钮赋予不同的整数值；如果控 制变量是 StringVar，则应为每个单选钮赋予不同的字符串值。下面这个例子将三个单选钮组 合成一组：

```
>>> v = IntVar()
>>> v.set(1)
>>> Radiobutton(root,text="One",variable=v,value=1).pack()
>>> Radiobutton(root,text="Two",variable=v,value=2).pack()
>>> Radiobutton(root,text="Three",variable=v,value=3).pack() 
```

其中三个单选钮共享一个 IntVar 型的控制变量 v，且分别设置了值 1、2、3。第二行 v.set(1) 的作用是设置初始默认选项。上述语句序列的执行效果如图 8.9 所示。另外，图中三个单选 钮是居中对齐，不太美观，可以用布局管理器设置对齐方式，详见 8.2.4。

![](img/程序设计思想与方法 248198.png)

图 8.9 单选钮构件

文本编辑区

文本编辑区是允许用户输入和编辑数据的区域，用户使用键盘在这个区域中输入文本，

输入过程中随时可以进行编辑，如光标定位、修改、插入等。有的文本编辑区只允许输入一 行文本，有的则允许输入多行。文本编辑区一般可以设置行和列的大小，并且可以通过滚动 条来显示、编辑更多的文本。

> ① 单选钮的英文是 radio button，名称源自收音机中预置电台按钮，选一个台的同时就取消了另一个台。

Tkinter 提供的 Entry 类可以实现单行文本的输入和编辑，不妨称之为录入框。下面的语 句创建并布置一个录入框构件：

```
>>> Entry(root).pack() 
```

运行结果是在窗口中出现一行空白区域，点击此区域后会出现一个闪烁的光标，这时就可以 在其中输入文本了。图 8.10 是输入了一些文本后的效果：

![](img/程序设计思想与方法 248477.png)

图 8.10 录入框构件

当用户输入了数据之后，应用程序显然需要某种手段来获取用户的输入，以便对数据进行处理。为此，可以通过 Entry 对象的 textvariable 属性将录入框与一个 StringVar 类型的控制 变量相关联，具体做法如下：

```
>>> v = StringVar()
>>> e = Entry(root,textvariable = v)
>>> e.pack() 
```

此后程序中就可以利用 v.get()来获取录入框中的文本内容。假设用户在录入框内键入了文 本“hello”，那么就有

```
>>> print v.get() hello 
```

另外，程序中还可以通过 v.set()来设置录入框的内容：

```
>>> v.set('new text') 
```

可以看到录入框中的文本立即变成了“new text”。 很多应用程序利用录入框作为用户登录系统时输入用户名和密码的界面元素，其中密码录入框一般不回显用户的输入，而是用“*”代替，这在 Tkinter 中很容易做到，只需将录入 框对象的 show 属性设置为“*”即可：

```
e.config(show='*') 
```

除了 Entry 类，Tkinter 还提供一个支持多行文本录入与编辑的文本区构件类：Text。两 者的用法是类似的：

```
>>> Text(root).pack() 
```

运行结果是在窗口中出现了一个多行的空白区域，在此区域可输入、编辑多行文本。Text 构 件的用途非常多，用法也比 Entry 复杂，这里就不详细介绍了。

框架

利用前面几节介绍的基本构件虽然能够实现简单的图形界面，但不足以搭建出美观的复 杂图形界面。为了将基本构件在界面中有层次地组织起来，还需要构件容器。如我们在 8.1.2 中描述的，框架就是一种容器，其主要用途是将一组相关的基本构件组合成为一个“复合” 构件。利用框架对窗口进行模块化分隔，即可建立复杂的图形界面结构。每个框架都是一个 独立的区域，可以独立地对其中包含的子构件进行布局。

Tkinter 提供了 Frame 类来创建框架构件，框架的宽度和高度分别用 width 和 height 属性 来设置，框架的边框粗细用 bd（或 border、borderwidth）属性来设置（默认值为 0，即没有 边框），边框的 3D 风格用 relief 属性来设置（默认是与环境融合的 flat 风格，其他可选的值 还有 groove、sunken、raised 和 ridge）。框架构件和基本构件一样需要先创建再布局，例如：

```
>>> f = Frame(root,width=300,height=400,bd=4,relief="groove")
>>> f.pack() 
```

这个框架的边框风格是 groove，读者可以试试其他边框风格分别是什么样子的。顺便说一下， relief 属性也适用于按钮构件。

下面这个例子演示了如何将框架用作容器来组合构件，图 8.11 是其执行效果。

```
>>> f = Frame(root,bd=4,relief="groove")
>>> f.pack()
>>> Checkbutton(f,text="Math").pack()
>>> Checkbutton(f,text="Python").pack() 
```

```
>>> Checkbutton(f,text="English").pack() 
```

![](img/程序设计思想与方法 249951.png)

图 8.11 利用框架组合构件

除了作为容器来组合多个构件的用途，框架还可用于图形界面的空间分隔或填充，例如：

```
>>> Label(root,text="one").pack()
>>> Frame(height=2,bd=1,relief="sunken").pack(fill=X,pady=5) 
```

```
>>> Label(text="two").pack() 
```

其中第二行语句定义的框架只起着分隔两个标签构件的作用，该框架在根窗口中以 x 方向填 满（fill=X）、y 方向上下各填充 5 个像素空间（pady=5）的方式进行 Pack 布局。效果见图 8.12：

![](img/程序设计思想与方法 250153.png)

图 8.12 利用框架分隔构件

后文（见 8.4.1）会介绍，我们经常将 GUI 应用程序封装成类，尤其是封装成 Frame 的 子类。这样做的好处是可以将程序逻辑与用户界面融为一体，界面元素之间的交互情况对外 部是隐藏的。

菜单

菜单也是 GUI 最常用的构件之一。就像饭店里用的菜单一样，菜单构件是一个由许多菜 单项组成的列表，每个菜单项表示一条命令或一个选项。用户通过鼠标或键盘选择菜单项， 以执行命令或选中选项，由此可见菜单兼具命令按钮、勾选钮和单选钮的功能。另一方面， 菜单又不像大量命令按钮、勾选钮和单选钮那么占空间，因为菜单在不用时通常是“合上” 的，在界面中只是一个占用极少空间的菜单按钮，直到用户点击菜单按钮才会展开整个菜单。 图形界面中一般有多个菜单，它们通常以相邻的方式布置在一起，形成窗口的菜单栏，并且 一般置于窗口顶端。

除了菜单栏里的菜单，GUI 中还常用一种弹出式菜单，这种菜单平时在界面中是不可见 的，当用户在界面中点击鼠标右键时才会“弹出”一个与点击位置相关的菜单。

有时候菜单中一个菜单项的作用是展开另一个菜单，形成“级联式”菜单。

Tkinter 提供 Menu 类用于创建菜单构件，具体用法是先创建一个菜单构件实例，并与某 个窗口（根窗口或者顶层窗口）进行关联，然后再为该菜单添加菜单项。与根窗口关联的菜 单实际上构成了根窗口的菜单栏。菜单项可以是简单命令、级联式菜单、勾选钮或一组单选 钮，分别用 add_command、add_cascade、add_checkbutton 和 add_radiobutton 来添加。为了使 菜单结构清晰，还可以用 add_separator 在菜单中添加分割线。

例如，下列语句以交互方式创建了一个菜单（假设已经创建了根窗口 root）：

```
>>> m = Menu(root)
>>> root.config(menu=m)
>>> m.add_command(label="File")
>>> m.add_command(label="Edit") 
```

其中第一条语句创建菜单实例 m（作为 root 的子构件）；第二条语句将 root 的 menu 属性设置 为 m ①，这导致将 m 布置于根窗口的顶部，形成菜单栏；第三、四条语句创建 m 的两个命 令菜单项。执行结果如图 8.13 所示。另外从上面的语句可以看到，菜单构件与前面介绍的构 件都不同，不需要调用布局管理器来使之可见，Tkinter 会自动布局并显示菜单。

![](img/程序设计思想与方法 251164.png)

图 8.13 菜单构件

上面这个例子其实没什么用，因为没有为命令菜单项指定相应的处理代码。另外，在实际应用中，窗口菜单栏里的菜单项通常是一个级联菜单，而不是简单命令菜单项。下面看一 个更实用的例子：

【程序 8.4】eg8_4.py

```
from Tkinter import *
def callback():
    print "hello from menu"
root = Tk()
m = Menu(root) 
root.config(menu = m) 
filemenu = Menu(m)
m.add_cascade(label="File", menu=filemenu) 
filemenu.add_command(label="New", command=callback)
filemenu.add_command(label="Open...", command=callback) 
filemenu.add_separator() 
filemenu.add_command(label="Exit", command=callback) 
helpmenu = Menu(m)
m.add_cascade(label="Help", menu=helpmenu) 
helpmenu.add_command(label="About...", command=callback)
mainloop() 
```

> ① 也可采用 root['menu'] = m 的语法，参见 8.2.3.1。

程序 8.4 首先以根窗口为父构件创建菜单构件 m，接着将 m 设置为根窗口的菜单栏；然 后以 m 为父构件创建另两个菜单构件 filemenu 和 helpmenu，它们分别构成菜单 m 的菜单项 “File”和“Help”的级联菜单。菜单 filemenu 又由三个命令菜单项组成（中间有一道分隔 线），菜单 helpmenu 中只有一个命令菜单项。各个菜单在界面中的位置由 Tkinter 自动布局， 不需要调用布局管理器。为了简化程序，我们将所有命令菜单项都关联到同一个函数 callback， 实际应用程序当然应该为每个命令编制各自的处理函数。执行本程序并点击 File 菜单项之后 的结果如图 8.14 所示：

![](img/程序设计思想与方法 252338.png)

图 8.14 程序 8.4 的执行结果

顶层窗口

迄今我们所写的程序都只有一个窗口，即根窗口。如所熟知的，像 Word 之类的应用程 序是多窗口的，每打开一个文档都新开一个窗口。为了支持多窗口应用程序，Tkinter 提供 Toplevel 类用于创建顶层窗口构件。顶层窗口的外观与根窗口一样，可以独立地移动和改变 大小，并且不需要像其他构件那样必须在根窗口中进行布局后才显示。一个应用程序只能有 一个根窗口，但可以创建任意多个顶层窗口。例如：

```
>>> root = Tk()
>>> Label(root,text="hello").pack()
>>> top = Toplevel()
>>> Label(top,text="world").pack() 
```

这个语句序列先创建根窗口，在根窗口中创建一个标签，然后创建了一个顶层窗口，又在顶 层窗口中创建了一个标签。执行结果如图 8.15 所示。

![](img/程序设计思想与方法 252743.png)

图 8.15 顶层窗口

对上例要说明的是，虽然创建 Toplevel 构件 top 时没有指定以根窗口 root 作为父构件， 但 top 确实是 root 的子构件，因此关闭 top 并不会结束程序，因为根窗口仍在工作；但若关 闭根窗口，则包含 top 在内的整个界面都会关闭。所以顶层窗口虽然具有相对的独立性，但 它不能脱离根窗口而存在。即使在没有根窗口的情况下直接创建顶层窗口，系统也会自动先 创建根窗口。

与根窗口类似，可以调用 Toplevel 类的 title 和 geometry 方法来设置它的标题和大小：

```
>>> top.title('hello toplevel')
>>> top.geometry('400x300') 
```

当然也可以为顶层窗口建立菜单，方法和根窗口类似，这里就不赘述了。

# 8.2.4 布局

### 8.2.4 布局

布局指的是界面元素在界面中的位置安排。Tkinter 中提供了布局管理器，其任务是根据 程序员的要求以及其他一些约束来安排构件的位置。使用布局管理器的优点是程序员不需要 了解底层显示系统的细节，可以在较高层次上考虑界面布局问题。

如前所述，多数构件在创建之后还需进行布局才会显示在屏幕上，即要经过两个步骤：

```
w = Constructor(parent,...) w.GeometryManager(...) 
```

其中 Constructor 是构件类（如 Label，Button 等），parent 是父构件，GeometryManager 是布局管理器方法。Tkinter 提供了三种布局管理器：Pack、Grid 和 Place。

Pack 布局管理器

Pack 布局管理器以紧凑的方式将构件在窗口中“打包”，调用构件的 pack 方法即可以这 种方式布局。具体的打包方式可以用一个比方来说明：设想窗口是由弹性材料制成的，当要 放入一个构件时，就先把窗口空间撑大到足够容纳该构件，然后将构件紧贴内部的某条边（缺 省是顶边）放入，然后重复此过程不断放入构件。可见，在缺省情形下，放入同一个窗口的 所有构件是沿垂直方向自顶向下一个紧贴一个进行布置的，但可以通过 pack 方法的 side 选项 设置成沿水平方向打包。

例如，执行下列语句后得到的布局效果如图 8.16(a)所示。

```
>>> Label(root,text="Input a number:").pack()
>>> Entry(root).pack()
>>> Button(root,text="OK").pack() 
```

而执行下列语句后的布局效果如图 8.16(b)所示，这里用到了 side 属性：side="left"使得构件 贴着左边放置。

```
>>> Label(root,text="Input a number:").pack(side="left")
>>> Entry(root).pack(side="left")
>>> Button(root,text="OK").pack(side="left") 
```

![](img/程序设计思想与方法 254004.png)

![](img/程序设计思想与方法 254006.png)

图 8.16 Pack 布局管理器

如果对窗口中的所有基本构件以打包方式布局，将使大大小小的构件形成一摞，显然不 美观。实际应用中常见的做法是对框架进行打包布局，一个一个框架像集装箱一样并排或堆 叠，然后再将基本构件作为各框架的子构件进行布局，这样能使界面整齐美观。

虽然 Pack 管理器还提供其他布局选项，但在此不多介绍了，因为我们有更灵活、更好用 的布局管理器：Grid 和 Place。

pack 方法的“逆”方法是 pack_forget 方法，意为将用 pack 布局的构件从界面中拿掉， 从而构件变成不可见。注意，这时构件作为对象仍然存在，只是未显示在界面中而已，我们 随时可以再次调用任何布局管理器方法来使构件可见。

rid 布局管理器*

Grid 布局管理器将窗口或框架视为一个由行和列构成的二维表格，并将构件放入行列交 叉处的单元格中。为了使用这种布局，只需先创建构件，再用 grid 方法的选项 row 和 column 指定行、列编号即可。不需要预先定义表格的尺寸，Grid 布局管理器会根据构件的大小自动 调整：每一列的宽度由该列中最宽的构件决定，每一行的高度由该行最高的构件决定。行、列都是从 0 开始编号，row 的缺省值为当前下一空行，column 的缺省值总为 0。可 以在布置构件时指定不连续的行号或列号，这相对于预留了一些行列，但这些预留的行列是 不可见的，因为行列上没有构件存在，也就没有宽度和高度。

Grid 布局管理器的使用非常简单，可以说是进行图形界面布局的首选工具。先看一个简 单例子：

```
>>> Label(root,text="ID Number:").grid()
>>> Label(root,text="Name:").grid()
>>> Entry(root).grid(row=0,column=1)
>>> Entry(root).grid(row=1,column=1) 
```

其中第一条语句使用缺省行号 0 和缺省列号 0 来安排标签“ID Number:”，第二条语句使用缺省行号 1 和缺省列号 0 来安排标签“Name”，后面两条语句在指定的位置安排录入框。布局效果如图 8.17 所示：

![](img/程序设计思想与方法 254946.png)

图 8.17 Grid 布局

从图 8.17 可以看出，标签构件在单元格里是居中放置的，如果觉得这种对齐方式不好看， 可以用 grid 方法的 sticky 选项来改变对齐方式。

Tkinter 中常利用“方位”概念来指定对齐方式，具体方位值包括 N、NE、E、SE、S、 SW、W、NW 和 CENTER（见图 8.18）。将 sticky 选项设置为某个方位，就表示将构件沿单元格的某条边或某个角对齐。

![](img/程序设计思想与方法 255159.png)

图 8.18 方位

如果构件比单元格小，未能填满单元格，则可以指定如何处理多余空间，比如在水平方 向或垂直方向拉伸构件以填满单元格。可以利用方位值的组合来使构件延伸，例如若将 sticky 设置为 E+W，则构件将在水平方向延伸，占满单元格的宽度；若设置为 E+W+N+S（或 NW+SE），则构件将在水平和垂直两个方向延伸，占满整个单元格。

如果想让一个构件占据多个单元格，可以使用 grid 方法的 rowspan 和 columnspan 选项来 指定在行和列方向上的跨度。例如，下面的语句序列能产生如图 8.19 所示的复杂布局：

```
>>> Label(root,text="ID Number:").grid(sticky=E)
>>> Label(root,text="Name:").grid(sticky=E)
>>> Entry(root).grid(row=0,column=1)
>>> Entry(root).grid(row=1,column=1)
>>> Checkbutton(root,text="Registered User").grid(
... columnspan=2,sticky=W)
>>> Label(root,text="X").grid(row=0,column=2,
... columnspan=2,rowspan=2,sticky=W+E+N+S)
>>> Button(root,text="Zoom In").grid(row=2,column=2)
>>> Button(root,text="Zoom Out").grid(row=2,column=3) 
```

![](img/程序设计思想与方法 255820.png)

图 8.19 利用 Grid 进行复杂布局

下面再看一个利用框架来实现复杂界面结构的例子：

```
>>> f1 = Frame(root,width=100,height=100,bd=4,relief="groove")
>>> f1.grid(row=1,column=1,rowspan=2,sticky=N+S+W+E)
>>> Checkbutton(f1,text="PC").grid(row=1,sticky=W)
>>> Checkbutton(f1,text="Laptop").grid(row=2,sticky=W)
>>> f2 = Frame(root,width=100,height=50,bd=4,relief="groove")
>>> f2.grid(row=1,column=2,columnspan=2,sticky=N)
>>> b1 = Button(root,text="OK",width=6)
>>> b1.grid(row=2,column=2,sticky=E+W,padx=2)
>>> b2 = Button(root,text="Cancel",width=6)
>>> b2.grid(row=2,column=3,sticky=E+W,padx=2) 
```

结果如图 8.20 所示。可以看出，这个例子大致实现了图 8.2 所要求的界面。

![](img/程序设计思想与方法 256480.png)

图 8.20 利用框架的布局

grid 方法的“逆”方法是 grid_forget 方法，意为将用 grid 布局的构件从界面中拿掉，从 而构件变成不可见。注意，这时构件作为对象仍然存在，只是未显示在界面中而已，我们随 时可以再次调用任何布局管理器方法来使构件可见。

Place 布局管理器*

Place 布局管理器直接指定构件在父构件中的位置坐标。为使用这种布局，只需先创建构 件，再调用构件的 place 方法，该方法的选项 x 和 y 用于设定坐标。父构件（窗口或框架） 的坐标系统以左上角为(0,0)，x 方向向右，y 方向向下。

由于(x,y)坐标确定的是一个点，而子构件可看作是一个矩形，这个矩形怎么放置在一个 点上呢？Place 通过“锚点”来处理这个问题：利用方位值（见图 8.18）指定子构件的锚点， 再利用 place 方法的 anchor 选项来将子构件的锚点定位于父窗口的指定坐标处。利用这种精 确的定位，可以实现一个或多个构件在窗口中的各种对齐方式。anchor 的缺省值为 NW，即 构件的左上角。例如下面两条语句分别将两个标签置于根窗口的(0,0)和(199,199)处，定位锚 点分别是（默认的）NW 和 SE：

```
>>> Label(root,text="Hello").place(x=0,y=0)
>>> Label(root,text="World").place(x=199,y=199,anchor=SE) 
```

下列语句序列围绕根窗口的点(100,100)按不同锚点布置了若干个按钮：

```
>>> Button(root,text="CCCCCCCCCCCCCCCCCC").place(x=100,y=100,
... anchor=CENTER)
>>> Button(root,text=" NW ").place(x=100,y=100,anchor=NW)
>>> Button(root,text="E").place(x=100,y=100,anchor=E)
>>> Button(root,text="W").place(x=100,y=100,anchor=W)
>>> Button(root,text=" SE ").place(x=100,y=100,anchor=SE) 
```

以上语句的执行结果如图 8.21 所示。

![](img/程序设计思想与方法 257475.png)

图 8.21 利用 Place 布局

Place 布局管理器既可以像上例这样用绝对坐标指定位置，也可以用相对坐标指定位置。 相对坐标通过选项 relx 和 rely 来设置，取值范围为 0～1，表示构件在父构件中的相对比例 位置，如 relx=0.5 即表示父构件 x 方向上的二分之一处。相对坐标的好处是当窗口改变大小 时，构件位置将随之调整，不像绝对坐标固定不变。例如下面这条语句将标签布置于水平方 向四分之一、垂直方向二分之一处，定位锚点是 SW：

```
Label(root,text="Hello").place(relx=0.25,rely=0.5,anchor=SW) 
```

除了指定构件位置，Place 布局管理器还可以指定构件大小。既可以通过选项 width 和 heightPlace 来定义构件的绝对尺寸，也可以通过选项 relwidth 和 relheight 来定义构件的相对 尺寸（即相对于父构件两个方向上的比例值）。

Place 是最灵活的布局管理器，但用起来比较麻烦，通常不适合对普通窗口和对话框进行 布局，其主要用途是实现复合构件的定制布局。

place 方法的“逆”方法是 place_forget 方法，意为将用 place 布局的构件从界面中拿掉， 从而构件变成不可见。注意，这时构件作为对象仍然存在，只是未显示在界面中而已，我们 随时可以再次调用任何布局管理器方法来使构件可见。

# 8.2.5 对话框*

### 8.2.5 对话框*

除了利用窗口中的各种构件之外，应用程序与用户进行交互的另一个重要手段是对话框。 对话框是一个独立的顶层窗口，通常是在程序执行过程中根据需要而“弹出”的窗口，用于 从用户获取输入或者向用户显示消息。

对话框分为两种类型：模态（modal）和非模态（modeless）对话框①。模态对话框在关 闭之前将阻止程序其他窗口的操作，而非模态对话框则不会阻止程序其他窗口的操作。模态 对话框常用于向用户警告重要信息，或者等待用户输入必需的数据（如登录用户名和密码、 打开或保存文件输入文件名等）。

Tkinter 提供若干标准模块用于创建弹出式对话框：

*   tkMessageBox 模块：提供一系列用于显示信息或进行简单对话的消息框，可通过调 用函数 askokcancel、askquestion、askretrycancel、askyesno、showerror、showinfo 和 showwarning 来创建。

*   tkFileDialog 模块：提供用于文件浏览、打开和保存的对话框，可通过调用函数 askopenfilename 和 asksaveasfilename 来创建。

*   tkColorChooser 模块：提供用于选择颜色的对话框，可通过函数 askcolor 来创建。

> ① 这里“模态”的意思是：对话框影响着程序的某种执行模式（mode）、状态，因此必须完成对话才能继续。 非模态对话框则不表示特定程序模式，主程序可以不管对话结果而继续执行。

以上各种标准对话框模块的更多细节请参考本章附录或其他参考资料，在此我们只用几 个简单例子演示一下其用法。下面这个语句序列弹出一个简单的对话框（图 8.22①），然后根 据用户的回答进行适当处理。

```
>>> from Tkinter import *
>>> from tkMessageBox import *
>>> root = Tk()
>>> answer = askokcancel("Dialog","Is that OK?")
>>> if answer:
... print "OK" 
```

![](img/程序设计思想与方法 258738.png)

图 8.22 askokcancel 对话框

![](img/程序设计思想与方法 259023.png)下面这个语句尝试打开一个文件，如果打开失败则弹出一个报错消息框（图 8.23），并且 还会发出报警声响：

```
>>> try:
...     f = open(filename)
... except:
...     showwarning("Open file","Open failed") 
```

图 8.23 showwarning 消息框

标准对话框模块对于应用程序的对话框设计通常已经够用，但有些应用程序可能需要更 复杂的对话框，这时我们可以定制对话框。设计自定义的对话框窗口与创建其他窗口并无本 质上的不同，主要步骤都是先创建 Toplevel 构件，然后添加所需的输入区、按钮和其他构件。 下面是一个定制消息框的简单程序：

> ① 从图中可见按钮文本是中文，这是因为 GUI 工具包都建立在底层操作系统的窗口管理器之上，本书作者 的计算机使用中文 Windows，其底层窗口管理器为常见按钮自动提供了中文文本。如果是英文版操作系统， 应该显示如函数名所提示的“OK”、“Cancel”、“Yes”、“No”等。

【程序 8.5】eg8_5.py

```
from Tkinter import *
def myMessageBox():
    top = Toplevel(height=200,width=400) 
Label(top,text='hello').pack()
root = Tk()
Button(root,text='click me',command = myMessageBox).pack() 
root.mainloop() 
```

运行此程序 ，可看到根 窗口中有一 个“ click me ”按钮， 点击该按钮 将调用函数 myMessageBox，此函数首先创建一个顶层窗口，然后在其中添加一个标签，这相当于定制了 一个简陋的消息框。

# 8.3 Tkinter 事件驱动编程

## 8.3 Tkinter 事件驱动编程

在 8.2 节中我们学习了图形用户界面中的各种构件的用法，至此我们已经能够为应用程 序搭建用户界面的外观部分，用户界面的另一个重要部分是各界面元素所对应的程序功能。 GUI 应用程序与普通应用程序的一个不同之处就在于，实现程序功能的代码与图形界面元素 相关联，这导致了一种新的程序执行模式——事件驱动。8.1.3 中简单介绍了事件驱动编程的 基本概念，现在我们来详细介绍 Tkinter 的事件驱动编程。

# 8.3.1 事件和事件对象

### 8.3.1 事件和事件对象

事件是针对应用程序所发生的事情，并且需要应用程序对它做出响应或进行处理。Tkinter 中定义了很多种事件，足以支持常见的 GUI 应用程序开发。

Tkinter 事件可以用特定形式的字符串来描述，称为事件模式。事件模式的一般形式是：

```
<modifier-type-detail> 
```

其中类型符 type 指定事件类型，最常用的类型有分别表示鼠标事件和键盘事件的 Button 和 Key；修饰符 modifier 用于描述鼠标键或键盘的双击、组合等情况；细节符 detail 指定具体的 鼠标键或键盘按键，如鼠标的左中右三个键分别用 1、2、3 表示，键盘按键用相应字符或按 键名称表示。modifier 和 detail 是可选的，而且事件模式经常可以使用简化形式。例如

```
<Double-Button-1> 
```

描述符中，修饰符是 Double，类型符是 Button，细节符是 1，综合起来描 述的事件就是双击鼠标左键。

常用的鼠标事件包括：

*   <ButtonPress-1>：按下鼠标左键。可简写为<Button-1>甚至<1>①。类似地有<Button-2>（按下鼠标中键）和<Button-3>（按下鼠标右键）。

*   <B1-Motion>：按下鼠标左键并移动鼠标。类似有<B2-Motion>和<B3-Motion>。

*   <Double-Button-1>：双击鼠标左键。

*   <Enter>：鼠标指针进入构件。

*   <Leave>：鼠标指针离开构件。

> ① 从易理解和简明的标准看，<Button-1>形式最可取。

常用的键盘事件包括：

*   <Key-a>：按下 a 键。可简写为 a（不用尖括号！）。可打印字符（字母、数字和标点 符号）都可像字母 a 这样使用，但有两个例外：空格键对应的事件是<space>，小于 号键对应的事件是<less>。注意：1 是键盘事件，而<1>是鼠标事件。

*   <Return>：按下回车键。非可打印字符都可像回车键这样用<键名>表示对应事件，例如<Tab>、<Shift_L>、<Control_R>、<Up>、<Down>、<F1>等等。

*   <Key>：按下任意键。

*   <Shift-Up>：同时按下 Shift 键和↑键。类似的还有 Alt 组合、Ctrl 组合。

每个事件都导致系统创建一个 Event 对象，并将该对象传递给事件处理函数。事件对象 具有若干描述事件的属性，常用的有：

*   x 和 y：鼠标点击位置坐标（相对于构件左上角），单位是像素。

*   x_root 和 y_root：鼠标点击位置坐标（相对于屏幕左上角），单位是像素。

*   num：点击的鼠标键号，1、2、3 分别表示左、中、右键。

*   char：如果按下 ASCII 字符键，此属性即是该字符；如果按下特殊键，此属性为空 串。

*   keysym：如果按下普通 ASCII 字符键，此属性即是该字符；如果按下特殊键，此属 性设置为该键的名称（是个字符串）。

*   keycode：所按键的编码。注意，此编码无法区分该键上的不同字符，即它不是键上 字符的编码。

*   keysym_num：这是 keysym 的数值表示。对普通单字符键来说，就是 ASCII 码。 例如，按下任意键都可触发<Key>事件，在事件处理函数中可以根据传递来的事件对象的 char 属性来确定具体按下的是哪一个键。

# 8.3.2 事件处理

### 8.3.2 事件处理

GUI 应用程序的核心是对各种交互事件的处理程序。应用程序一般在完成建立图形界面 等初始化工作后都会进入一个事件循环，等待事件发生并触发相应的事件处理程序。Tkinter 程序通过 mainloop 方法进入事件循环，而事件与相应事件处理程序之间是通过绑定建立关联 的。

最常见的绑定形式是针对构件实例的：

```
<构件实例>.bind(<事件描述符>,<事件处理程序>) 
```

其语义是：若针对<构件实例>发生了与<事件描述符>相匹配的事件，则调用<事件处理程序>。 调用事件处理程序时，系统会传递一个 Event 类的对象作为实际参数，该对象描述了所发生 事件的详细信息。

事件处理程序一般都是用户自定义的函数。这种函数在应用程序中定义，但不由应用程 序调用，而是由系统调用，所以一般称为回调（callback）函数。

GUI 应用程序经常封装为类，在这种情况下，事件处理程序常常定义为应用程序类的方 法。我们将在 8.4.1 中通过例子详细介绍这种做法。

先看一个处理鼠标点击事件的例子：

【程序 8.6】eg8_6.py

```
from Tkinter import *
def callback(event):
    print "clicked at", event.x, event.y
root = Tk()
f = Frame(root, width=100, height=100) 
f.bind("<Button-1>", callback) 
f.pack()
root.mainloop() 
```

本程序在根窗口中添加了一个框架构件，然后把框架构件与<Button-1>事件进行了绑定， 对应<Button-1>事件的回调函数是 callback，意思是每当在框架中点击鼠标左键时，都将触发 callback 执行。系统执行 callback 时，将一个描述事件的 Event 类对象作为参数传递给该函数， 该函数从事件对象参数中提取点击位置信息并在控制台输出类似“clicked at 44 63”的信息。

键盘事件与焦点

当图形界面中存在许多构件时，如果是用鼠标直接点击某个窗口或构件，程序自然就知

道要操作哪个构件。但如果是按一下键盘，应该由哪个构件做出响应呢？GUI 引入了“焦点” 概念：图形界面中有唯一焦点，任何时刻只能有一个构件占有焦点，键盘事件总是发送到当 前占有焦点的构件。焦点的位置可以通过构件的 focus_set()方法来设置，也可以用键盘上的 Tab 键来轮转。因此，键盘事件处理比鼠标事件处理多了一个设置焦点的步骤，如下例所示：

【程序 8.7】eg8_7.py

```
from Tkinter import *
def printInfo(event):
    print "pressed", event.char
root = Tk()
b = Button(root,text = 'Press any key') 
b.bind('<Key>',printInfo)
b.focus_set() 
b.pack() 
root.mainloop() 
```

本程序创建了一个按钮构件，该按钮与按任意键事件<Key>进行绑定，事件处理程序是 回调函数 printInfo。此程序的 b.focus_set()语句将按钮设为键盘焦点，从而按下任何键都会由 按钮响应，并触发 printInfo 函数来处理事件，处理过程是显示按下的键的字符。读者可以思 考一下：本例中绑定的是<Key>事件，运行时如果输入上档键（如@#$%^&之类）会出现什 么结果呢？

绑定到多个事件 一个构件可以响应多种事件，例如下面这个程序同时响应鼠标和键盘事件：

【程序 8.8】eg8_8.py

```
from Tkinter import *
def callback1(event):
    print "pressed", event.char
def callback2(event): f.focus_set()
    print "clicked at", event.x, event.y
root = Tk()
f = Frame(root, width=100, height=100) 
f.bind("<Key>", callback1) 
f.bind("<Button-1>", callback2) 
f.pack()
root.mainloop() 
```

此程序在根窗口中创建一个框架构件，并为框架构件同时绑定了任意键事件<Key>和鼠 标左键事件<Button-1>。运行此程序，先在框架中点击鼠标，从而触发 callback2 函数的执行， 该函数又将框架设置为键盘焦点。此后，按下任何键都将触发 callback1 函数的执行，其功能 是显示所按的字符。运行此程序后如果没有在框架中先点击鼠标，则框架未获得焦点，也就 不会对键盘事件进行处理。

当构件绑定的多个事件之间具有“特殊与一般”的关系，总是调用最“近”的事件处理 程序。例如，如果将某构件与任意键事件<Key>绑定，相应事件处理程序是 h1，又与回车键 事件<Return>绑定，相应事件处理程序是 h2，那么当按下回车键时，处理此事件的将是 h2。

绑定层次

前面三个例子中都是针对某个构件实例进行事件绑定，称为“实例绑定”。实例绑定只对 该构件实例有效，对其他实例——即使是同类型的构件——是无效的。除了实例绑定，Tkinter 还提供了其他事件绑定方式。实际上，Tkinter 中共有不同层次的四种绑定方法：

*   实例绑定：绑定只对特定构件实例有效，用构件实例的 bind 方法实现。

*   类绑定：绑定针对构件类，故对该类的所有实例有效，可用任何构件实例的 bind_class 方法实现。例如，为使 Button 类的所有实例都以同样方式响应回车键事件，可执行：

    ```
    root.bind_class("Button","<Return>",callback) 
    ```

*   窗口绑定：绑定对窗口（根窗口或顶层窗口）中的所有构件有效。用窗口的 bind 方 法实现，例如为使窗口中所有构件都以同样方式响应鼠标右键点击事件，可执行：

    ```
    root.bind('<Button-3>',callback) 
    ```

*   应用程序绑定：绑定对应用程序中的所有构件都有效。用任一构件实例的 bind_all 方法实现。例如，很多应用程序在运行时可以随时按下 F1 键以使用户得到帮助信 息，这可以通过建立 F1 键的应用程序绑定来实现：

    ```
    root.bind_all('<F1>',printHelp) 
    ```

下面这个例子演示了事件传递与绑定层次结合所带来的后果：

【程序 8.9】eg8_9.py

```
from Tkinter import *
def printInstance(event):
    print 'Instance:',event.keycode
def printToplevel(event):
    print 'Toplevel:',event.keycode
def printClass(event):
    print 'Class:',event.keycode
def printApp(event):
    print 'Application:',event.keycode
root = Tk()
b = Button(root,text = 'Press Return') 
b.bind('&lt;Return&gt;',printInstance) 
b.winfo_toplevel().bind('&lt;Return&gt;',printToplevel) 
root.bind_class('Button','&lt;Return&gt;',printClass) 
root.bind_all('&lt;Return&gt;',printApp)
b.pack() 
b.focus_set() 
root.mainloop() 
```

本程序中定义了四个层次的事件绑定，运行此程序并按下回车键，将得到如图 8.24 所示 的输出。这是因为<Return>事件首先被拥有焦点的按钮实例 b 捕获，并执行 printInstance 函 数。此后，<Return>事件还将向 b 的各级上层传递，从而依次被 b 所属的 Button 类、b 所属 的顶层窗口 root、b 所属的应用程序这三个层次捕获，分别导致 printClass、printTopleve 和 printApp 三个函数的执行。

![](img/程序设计思想与方法 265000.png)

图 8.24 多层绑定

关于程序 8.9 还有几点要说明：（1）程序中的 b.winfo_toplevel()方法返回 b 所属的顶层构 件，本例中即根窗口 root；（2）对程序代码与输出结果进行比较后可看出，事件的传递层次 与程序中绑定语句的次序没有关系；（3）类绑定与应用程序绑定可以通过任何构件来设置， 因此将上面程序中的 root.bind_class 和 root.bind_all 改成 b.bind_class 和 b.bind_all，结果也是 一样的。

协议处理

用过 Word 的读者都知道，如果编辑了文档还没有保存就去关闭程序窗口，Word 会弹出 一个对话框，询问用户是否要保存当前文档。如果我们希望利用事件绑定到事件处理程序来 实现这种功能，就面临一个问题：“关闭窗口”并不属于前面介绍过的事件类型，因此无法用 事件绑定来处理。

为此，Tkinter 提供了一种称为“协议处理”的机制，用于应用程序处理来自操作系统窗 口管理器的协议消息。处理过程是这样的：当用户企图关闭窗口，操作系统的窗口管理器就 会生成一条 WM_DELETE_WINDOW 的协议消息并发送给应用程序，应用程序再调用相应的 处理程序来处理这条消息。

窗口构件有一个称为 protocol 的方法，用于定义对协议消息的处理程序：

```
<窗口构件>.protocol("WM_DELETE_WINDOW",<处理程序>) 
```

其中窗口构件可以是根窗口或顶层窗口，处理程序是函数或方法。如此定义之后，当用户试 图关闭窗口时，我们自己的处理程序就会接管控制。处理程序可以弹出一个消息框询问用户 是否要保存当前数据，或者干脆忽略关闭窗口的请求。处理完毕之后，可以在处理程序中完 成关闭窗口的操作，方法是调用窗口的 destroy 方法。例如：

【程序 8.10】eg8_10.py

```
from Tkinter import * 
from tkMessageBox import *
def callback():
    if askokcancel("Quit","Do you really wish to quit?"): 
        root.destroy()
root = Tk() 
root.protocol("WM_DELETE_WINDOW", callback) 
root.mainloop() 
```

虚拟事件

我们也可以自定义新的事件类型，称为虚拟事件。虚拟事件的形式是<<事件名称>>，可 利用构件的 event_add 方法来创建。例如，如果想为构件 w 创建一个新事件<<MyEvent>>， 该事件由鼠标右键或键盘上的 Pause 键触发，则执行下列语句：

```
w.event_add("<<MyEvent>>","<Button-3>","<KeyPress-Pause>") 
```

此后就可以像系统定义的事件一样使用了。例如：

```
w.bind("<<MyEvent>>",myHandler) 
```

在构件 w 上点击右键或按下 Pause 键都会触发函数 myHandler。

# 8.4 模型－视图设计方法

## 8.4 模型－视图设计方法

# 8.4.1 将 GUI 应用程序封装成对象

### 8.4.1 将 GUI 应用程序封装成对象

GUI 编程的一个常用技术是将整个应用程序封装成一个类，在应用程序类中建立图形界 面并处理各种交互事件。具体来说，GUI 应用程序类应该首先创建一个主窗口，并在其中布 置所需的各种构件，然后再为各个构件编写事件处理程序（都是类的方法）。这种做法的好处 是：由于事件处理函数都定义为应用类的方法，而类的方法很自然地能访问类中的实例变量， 所以只要我们将界面中的各种构件也存储为实例变量，就能实现程序的处理代码与程序的图 形界面进行“无缝集成”。

在用 Tkinter 编程时，根据需要可以有多种方式来建立程序主窗口：

（1）在应用程序类中创建自己的根窗口，即程序自成体系。代码大致形如：

```
class MyApp:
    def __init__ (self): 
        root = Tk()
        b = Button(root,...)
        ...
        root.mainloop() 
app = MyApp() 
```

（2）程序主窗口是程序类外部的某个窗口的子构件，该外部窗口在创建程序实例时作为 参数传递给构造器。例如：

```
class MyApp:
    def __init__ (self,master): 
        f = Frame(master,...)
        b = Button(f,...)
        ...
        root = Tk()
app = MyApp(root) root.mainloop() 
```

（3）将应用程序类定义为框架构件类的子类，即程序就是窗口，窗口就是程序。如：

```
class MyApp(Frame): 
    def __init__ (self):
        Frame. __init__ (self) # 先用父类的构造器进行初始化
        b = Button(self,...)
        ...
app = MyApp() app.mainloop() 
```

在应用程序类的设计中，如果一个构件具有“全局性”，即多个方法都要访问该元素，那 么就需用一个实例变量来存储（引用）这个构件，因为类的实例变量在所有类方法中都可访 问，而局部变量只在某一个方法中可见。

作为例子，我们定义一个应用程序类 MyApp，该程序的用户界面包括窗口、标签和按钮。 我们采用上述第一种方式，即程序创建自己的根窗口。根窗口和标签构件被存储为实例变量 self.root 和 self.t，以便 MyApp 类的所有方法都能引用它们；两个按钮则被存储为局部变量 b1 和 b2，这样在其他方法中是不能引用它们的。

【程序 8.11】myapp.py

```
from Tkinter import * 
class MyApp:
    def __init__ (self): 
        self.root = Tk() 
        self.root.title("My App")
        self.t = Label(self.root,text="Spam") 
        self.t.pack()
        b1 = Button(self.root,text="Play",command=self.changeText) 
        b2 = Button(self.root,text="Quit",command=self.root.quit) 
        b1.pack()
        b2.pack() 
        self.root.mainloop() 
        self.root.destroy()
    def changeText(self):
        if self.t["text"] == "Spam":
            self.t["text"] = "Egg" 
        else:
        self.t["text"] = "Spam"
app = MyApp() 
```

程序 8.11 定义了类 MyApp，在其构造器 init__ 中首先创建根窗口 root，然后添加一个 标签和两个按钮。点击按钮 b1 时的回调函数是类 MyApp 中自定义的方法 changeText（功能 是改变标签的文本），点击 b2 时的回调函数是根窗口的内建方法 quit（退出事件循环）。标签 构件必须作为实例变量存储，因为 init 和 changeText 方法都要引用它；而根窗口和两个按 钮在本例中既可以作为实例变量存储，也可以作为局部变量存储。创建各构件并完成布局之 后进入事件循环，等待处理事件。

类只是一个定义，封装成类的应用程序如何执行呢？我们通常会为应用程序类定义一个 专门的启动方法 run，将来创建应用程序对象后通过调用对象的 run 方法来启动程序功能。本 例中 MyApp 程序对象 app 一经创建就自动进入程序主循环，这是因为我们将所有启动代码 包括 mainloop 都放在构造器 init**之中的缘故。程序启动后，点击 Play 按钮可以看到标签 内容在“Spam”和“Egg”之间切换。点击 Quit 按钮将退出事件循环，从而执行 init**的最 后一条语句 root.destroy 关闭根窗口①。

作为练习，读者可以用上述第二、三种方式来改写程序 8.11。

# 8.4.2 模型与视图

### 8.4.2 模型与视图

复杂应用程序经常可以分解成两个部分：核心逻辑和用户界面。程序的核心逻辑部分称

为模型（model），它负责为应用问题建模，管理应用问题的数据和行为，并对来自用户界面 的数据请求或数据更新指令进行响应。程序的用户界面部分称为视图（view），它负责显示模 型的当前数据状态，响应用户的交互动作。模型和视图是相互独立的，可以分开设计和测试， 从而简化程序结构、降低设计难度，这称为模型－视图（MV）设计方法。

模型与视图之间的桥梁称为控制器（controller）：用户通过用户界面发出交互动作，从而 触发事件处理器（回调函数）做出相应处理，导致模型的状态发生改变；模型状态的改变又 导致视图的更新，从而向用户输出结果。如果把模型和视图之间的控制器考虑进去，这种方 法也称为模型－视图－控制器（MVC）方法（图 8.25）。

![](img/程序设计思想与方法 268731.png)

图 8.25 模型－视图体系结构

用 MV 方法设计程序时，定义模型不需要用到视图中的元素，定义视图也不需要用到模 型中的数据，从而可以分别设计和测试。另外，同一模型可以使用不同的视图来达到不同的 目的，例如可以先设计一个基于文本界面的简单视图来测试模型的正确性，确定模型没有问 题后再去设计更美观易用的 GUI 视图。在实际开发中，经常将用户界面封装成界面对象，这样随时可以通过替换不同的界面对象来改变模型的外观和用户体验。 模型设计与视图设计在很多方面都不一样。为应用问题建立模型是“智力密集型”的工作，需要创造性的算法设计；而构造视图则是“劳动密集型”的工作，需要用户友好和美观。 模型的建立很难借助自动化的设计工具，而图形界面的构建大部分都可利用设计工具自动或 半自动地完成。

> ① 有的环境可能在退出事件循环时就自动关闭根窗口。

# 8.4.3 编程案例：汇率换算器

### 8.4.3 编程案例：汇率换算器

本节通过一个应用实例来介绍 MV 方法的具体应用。我们希望设计一个汇率换算器程序， 其功能是将外币换算成人民币，或者相反。最终的版本是图形用户界面的，但在设计过程中， 我们还会设计一个文本界面的版本用来测试程序功能的正确性。

我们首先设计程序模型，这是由 CCApp 类实现的。设计 CCApp 时并不限定将使用的界 面，但随着 CCApp 的细化设计，我们会得到有关界面的功能需求，从而有助于程序用户界 面的设计和实现。

程序规格

汇率换算器程序用于在外币与人民币之间进行换算。 输入：外币币种，换算方向，金额 输出：等值的目标币种金额

明确候选对象

根据程序需求来确定对解题有用的对象。汇率换算器处理的是货币，货币用一个简单的 符号或数值就能表示，没有必要封装成对象。我们只将应用程序模型部分封装成一个类 CCApp，该类的实例需要记录当前的汇率信息，并至少需要实现构造器方法 init__ 和程序启 动方法 run。也许还需要若干辅助方法，这只有到设计主算法时才会明确。

除了核心部分，程序的另一个组成部分是用户界面。我们将界面也封装成对象，这样做 的好处是：在不改变模型的情况下，通过换用不同界面对象即可改变程序的外观。假设程序 将使用的界面对象是 xInterface，目前还不清楚这个类应有的行为，但随着我们精化 CCApp 的设计，就会明确需要从用户输入什么信息和向用户显示什么信息，所有输入和输出正对应 着 xInterface 类要实现的方法。

实现模型

由于本章重点是用户界面，所以作为例子的汇率换算器程序的模型很简单：按照存储的 当前汇率信息，将给定数额的外币换算成人民币，或将人民币换算成外币。对如此简单的问 题，只需一个 CCApp 类即可实现。当然，对于复杂程序，模型会涉及多种对象，那样就需 要实现多个类。模型的设计可采用自顶向下逐步求精方法，在此逐步细化的过程中，即可逐 步明确用户界面应该提供哪些方法。下面是 CCApp 类的定义：

【程序 8.12 之一】ccapp.py

```
class CCApp:
    def init (self, inter): 
        self.xRate = {'USD':6.306,
            'Euro':8.2735,
            'Yen':0.0775,
            'Pound':10.0486}
        self.interface = inter
    def run(self): 
        while True:
            to,fc,amount,bye = self.interface.getInfo() 
            if bye:
                break
            elif to == 'RMB':
                result = amount * self.xRate[fc] 
            else:
                result = amount / self.xRate[fc] 
            self.interface.showInfo(result) 
```

首先看构造器 __init__()，它负责汇率换算器的初始化，具体就是用一个字典 self.xRate 来存储若干外币名称及其对人民币的汇率①。注意， __init__ 方法还有个参数 inter，它代表程 序的用户界面，后面我们会分别用两种用户界面对象传递给此参数，从而得到两种版本的换 算器程序。

将来创建汇率换算器实例之后，通过调用实例的 run 方法来启动换算功能。换算器的核 心算法是个循环，每次循环完成一次换算，换算所需的各种信息都来自用户界面。可以看出 总体上换算过程仍然是简单的 IPO（即输入——处理——输出）算法模式，涉及的输入信息 包括换算方向、换算的外币、换算金额和退出标志（通过界面提供的 getInfo 方法获得），输 出信息就是换算结果（通过界面提供的 showInfo 方法显示）。当用户在用户界面选择退出时， 则不再循环，程序结束。

至此，我们实现了汇率换算器的核心功能，实现了程序的模型部分。但现在还无法测试 程序，因为还没有建立用户界面。但模型对用户界面的基本要求已经确定了，就是要提供 getInfo 和 showInfo 方法，参见图 8.26。

![](img/程序设计思想与方法 270712.png)

图 8.26 模型-视图方法例 基于文本的用户界面

CCApp 类的定义中用到了很多用户界面的功能，可见模型的设计实现过程也揭示了用户 界面应当如何设计。和模型一样，我们将视图（用户界面）的功能也封装成一个类，这个界 面类必须包括 CCApp 类中所用到的所有方法：quit、close、getCurr、getDirection、getAmount 和 display。如果以不同方式来实现界面类 CCInterface，就能产生具有不同外观的换算器程序， 注意作为基础的模型 CCApp 类是不变的。可见视图与模型可以独立地设计，为同一模型可 以设计多种视图。

> ① 程序中的汇率数据是 2012 年 4 月 18 日的汇率。

由于一般来说 GUI 比较复杂，为了尽快测试模型的正确性，可以先设计一个简单的文本界面。这个界面纯粹用于测试，无需过多考虑用户友好性，因此我们以最简单最直接的方式 来实现 CCApp 所需的各种界面功能。

【程序 8.12 之二】ti.py

```
class TextInterface: 
    def __init__ (self):
        print "Welcome to Currency Converter!" 
        self.qFlag = False # Quit flag
        self.fc = 'USD' # foreign currency selected 
        self.to = 'RMB' # convert to?
        self.amt = 0 # amount to be converted
    def getInfo(self):
        self.qFlag = self.getQFlag() 
        if self.qFlag:
            self.close() 
        else:
            self.fc = self.getFC() 
            self.to = self.getTo() 
            self.amt = self.getAmount()
        return self.qFlag,self.fc,self.to,self.amt
    def getQFlag(self):
        ans = raw_input("Want to quit? (y/n) ") 
        if ans[0] in 'yY':
            return True 
        else:
            return False
    def getFC(self):
        return raw_input("Choose among {USD,Euro,Yen,Pound}: ")
    def getTo(self):
        ans = raw_input("Convert to RMB? (y/n) ") 
        if ans[0] in 'yY':
            return 'RMB' 
        else:
            return self.fc
    def getAmount(self):
        if self.to == 'RMB':
            return input("How much " + self.fc + "? ") 
        else:
            return input("How much RMB? ")
    def showInfo(self,r): 
        if self.to == 'RMB':
            print "%.2f %s ==&gt; %.2f RMB" % (self.amt,self.fc,r)
        else:
            print "%.2f RMB ==&gt; %.2f %s" % (self.amt,r,self.fc)
    def close(self): 
        print "Goodbye!" 
```

下面我们利用此用户界面来测试 CCApp 的正确性。为此目的，只需创建一个文本界面 对象，再创建 CCApp 对象，然后启动换算。测试程序如下：

【程序 8.12 之三】testti.py

```
from ccapp import CCApp
from ti import TextInterface
inter = TextInterface() 
cc = CCApp(inter) 
cc.run() 
```

以下是测试运行示例，黑体部分是用户输入。结果表明程序的模型部分实现了预期的功 能。

```
Welcome to Currency Converter! Want to quit? (y/n) n
Choose among {USD,Euro,Yen,Pound}: USD
Convert to RMB? (y/n) y
How much USD? 100
## 100.00 USD ==&gt; 630.60 RMB
Want to quit? (y/n) n
Choose among {USD,Euro,Yen,Pound}: Euro
Convert to RMB? (y/n) n
How much RMB? 10000
## 10000.00 RMB ==&gt; 1208.68 Euro
Want to quit? (y/n) y
Goodbye! 
```

实现 GUI

经过文本界面的测试，如果确信核心部分没有问题，即可转向设计更复杂但更加用户友 好的图形界面。我们要做的是确定图形界面的各种构件及布局，然后编写构件的处理代码。 与文本界面类似，图形界面需要提供的功能在模型设计过程已经确定了，图形界面必须支持 与文本界面相同的方法，另外也许还需要一些辅助方法。

根据模型部分所要求的界面功能来设计图形界面：选择要换算的外币种类，由于每次只 处理一种外币，故可用单选钮实现；输入和显示外币及等价人民币的金额，可用两个录入框 实现；双向换算和退出用三个命令按钮实现。至此即大致确定了图形界面的外观，接下来即 可为构件（主要是命令按钮）实现处理代码。最终得到如下 GUInterface 类定义：

【程序 8.12 之四】gui.py

```
from Tkinter import * class GUInterface:
def init (self): self.root = Tk()
self.root.title("Currency Converter")
self.qFlag = False # Quit flag
self.fc = StringVar() # foreign currency selected self.fc.set('USD')
self.to = 'RMB' # convert to?
self.amt = 0 # amount to be converted self.aRMB = StringVar() # amount of RMB self.aRMB.set('0.00')
self.aFC = StringVar() # amount of foreign currency self.aFC.set('0.00')
Label(self.root,textvariable=self.fc).grid( row=0,column=0,sticky=W)
Label(self.root,text='RMB').grid( row=0,column=2,sticky=W)
self.e1 = Entry(self.root,textvariable=self.aFC) self.e1.grid(row=1,column=0,rowspan=2)
self.e2 = Entry(self.root,textvariable=self.aRMB) self.e2.grid(row=1,column=2,rowspan=2)
self.b1 = Button(self.root,
text='----&gt;',command=self.toRMB) self.b1.grid(row=1,column=1)
self.b2 = Button(self.root,
text='&lt;----',command=self.toFC) self.b2.grid(row=2,column=1)
self.f = Frame(self.root) self.f.grid(row=3,column=0,columnspan=3) self.r1 = Radiobutton(self.f,text='USD',
variable=self.fc,value='USD') self.r1.grid(row=0,column=0)
self.r2 = Radiobutton(self.f,text='Euro',
variable=self.fc,value='Euro') self.r2.grid(row=0,column=1)
self.r3 = Radiobutton(self.f,text='Yen',
variable=self.fc,value='Yen') self.r3.grid(row=0,column=2)
self.r4 = Radiobutton(self.f,text='Pound',
variable=self.fc,value='Pound') self.r4.grid(row=0,column=3)
self.rate = Button(self.root,text='Update Rates') self.rate.grid(row=4,column=1)
self.qb = Button(self.root,text='Quit',command=self.close) self.qb.grid(row=5,column=1)
def getInfo(self): self.root.mainloop()
return self.qFlag,self.fc.get(),self.to,self.amt
def showInfo(self,r): rStr = "%.2f" % r if self.to == 'RMB':
self.aRMB.set(rStr) else:
self.aFC.set(rStr)
def toRMB(self): self.to = 'RMB'
self.amt = eval(self.aFC.get()) self.root.quit()
def toFC(self):
self.to = self.fc.get()
self.amt = eval(self.aRMB.get()) self.root.quit()
def close(self): self.qFlag = True self.root.quit() self.root.destroy() 
```

这个类中的 getInfo 和 showInfo 是被模型部分调用的方法，用于输入和输出；其他几个 方法都是辅助方法，用来设置输入输出的信息。在此需要解释一下用到的技术性手段：当核 心程序调用界面的 getInfo 方法时，self.root.mainloop 方法使图形界面进入事件循环，从而能 够处理用户在界面上的各种交互事件（如在录入框中输入数据、点击单选钮选择货币、点击 换算按钮等）。当用户点击换算按钮，相应的处理程序 toRMB 和 toFC 在设置有关信息后必 须用 self.root.quit 方法来退出事件循环，从而使 getInfo 方法结束并将控制返回核心部分。

下面我们利用此图形用户界面来实现图形版的汇率换算器。和前面测试文本界面一样， 在主程序中先创建一个图形界面对象，再创建 CCApp 对象，然后启动换算器。程序如下：

【程序 8.12 之五】testgui.py

```
from ccapp import CCApp 
from gui import GUInterface
inter = GUInterface() 
cc = CCApp(inter) 
cc.run() 
```

执行此程序，在图形界面中选择 Euro，并在 RMB 录入框中输入 10000，最后点击“<----” 按钮，得到的结果如图 8.27 所示：

![](img/程序设计思想与方法 275799.png)

图 8.27 图形版汇率换算器

从图 8.27 还可看到，我们的图形界面中还有一个前面未提到的按钮 Update Rates，这是 用来更新汇率数据的，但本程序中没有为此按钮编写处理程序，作为练习，读者可以自己试 着完善这个功能①。另外，支持换算的外币种类也很容易扩充。

至此我们完成了一个汇率换算器程序。通过这个程序的设计，我们看到，即使是如此简 单的程序，它的 GUI 设计也相当复杂。一般而言，图形界面由很多构件组成，创建构件并进 行布局是枯燥而繁琐的工作；而为构件编写相应的处理程序通常都比较简单直接。

# 8.5 练习

## 8.5 练习

1\. 编程实现一个计算器。可参考 Windows 的计算器。

2\. 编程实现一个简单的文本编辑器。可参考 Windows 的记事本。

3\. 编程实现一个 GUI 版的学生信息管理系统（参见 6.6 练习第 9 题）。

> ① 例如可以新开一个顶层窗口，在其中输入新的汇率数据，并更新 CCApp 实例的汇率字典 self.xRate。