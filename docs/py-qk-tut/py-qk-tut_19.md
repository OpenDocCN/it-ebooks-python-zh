## Python 深入 01 特殊方法与多范式

[`www.cnblogs.com/vamei/archive/2012/11/19/2772441.html`](http://www.cnblogs.com/vamei/archive/2012/11/19/2772441.html)

作者：Vamei 出处：http://www.cnblogs.com/vamei 欢迎转载，也请保留这段声明。

Python 一切皆对象，但同时，Python 还是一个多范式语言(multi-paradigm),你不仅可以使用面向对象的方式来编写程序，还可以用面向过程的方式来编写相同功能的程序(还有函数式、声明式等，我们暂不深入)。Python 的多范式依赖于 Python 对象中的特殊方法(special method)。

特殊方法名的前后各有两个下划线。特殊方法又被成为魔法方法(magic method)，定义了许多 Python 语法和表达方式，正如我们在下面的例子中将要看到的。当对象中定义了特殊方法的时候，Python 也会对它们有“特殊优待”。比如定义了 __init__()方法的类，会在创建对象的时候自动执行 __init__()方法中的操作。

(可以通过 dir()来查看对象所拥有的特殊方法，比如 dir(1))

### 运算符

Python 的运算符是通过调用对象的特殊方法实现的。比如：

![复制代码](img/rdb_epub_4593197691164204437.jpg)

```py
'abc' + 'xyz'            # 连接字符串 

```

实际执行了如下操作：

![复制代码](img/rdb_epub_4593197691164204437.jpg)

```py
'abc'.__add__('xyz')

```

![复制代码](img/rdb_epub_4593197691164204437.jpg)

所以，在 Python 中，两个对象是否能进行加法运算，首先就要看相应的对象是否有 __add__()方法。一旦相应的对象有 __add__()方法，即使这个对象从数学上不可加，我们都可以用加法的形式，来表达 obj.__add__()所定义的操作。在 Python 中，运算符起到简化书写的功能，但它依靠特殊方法实现。

Python 不强制用户使用面向对象的编程方法。用户可以选择自己喜欢的使用方式(比如选择使用+符号，还是使用更加面向对象的 __add__()方法)。特殊方法写起来总是要更费事一点。

尝试下面的操作，看看效果，再想想它的对应运算符

(1.8).__mul__(2.0)

True.__or__(False)

### 内置函数

与运算符类似，许多内置函数也都是调用对象的特殊方法。比如

![复制代码](img/rdb_epub_4593197691164204437.jpg)

```py
len([1,2,3])      # 返回表中元素的总数

```

![复制代码](img/rdb_epub_4593197691164204437.jpg)

实际上做的是

```py
[1,2,3].__len__()

```

![复制代码](img/rdb_epub_4593197691164204437.jpg)

相对与 __len__()，内置函数 len()也起到了简化书写的作用。

尝试下面的操作，想一下它的对应内置函数

(-1).__abs__()

(2.3).__int__()

### 表(list)元素引用

下面是我们常见的表元素引用方式

![复制代码](img/rdb_epub_4593197691164204437.jpg)

```py
li = [1, 2, 3, 4, 5, 6]
print(li[3])

```

![复制代码](img/rdb_epub_4593197691164204437.jpg)

上面的程序运行到 li[3]的时候，Python 发现并理解[]符号，然后调用 __getitem__()方法。

![复制代码](img/rdb_epub_4593197691164204437.jpg)

```py
li = [1, 2, 3, 4, 5, 6]
print(li.__getitem__(3))

```

![复制代码](img/rdb_epub_4593197691164204437.jpg)

尝试看下面的操作，想想它的对应

li.__setitem__(3, 0)

{'a':1, 'b':2}.__delitem__('a')

### 函数

我们已经说过，在 Python 中，函数也是一种对象。实际上，任何一个有 __call__()特殊方法的对象都被当作是函数。比如下面的例子:

![复制代码](img/rdb_epub_4593197691164204437.jpg)

```py
class SampleMore(object):
    def __call__(self, a):
        return a + 5
add = SampleMore()     # A function object
print(add(2))          # Call function    
map(add, [2, 4, 5])    # Pass around function object

```

![复制代码](img/rdb_epub_4593197691164204437.jpg)

add 为 SampleMore 类的一个对象，当被调用时，add 执行加 5 的操作。add 还可以作为函数对象，被传递给 map()函数。

当然，我们还可以使用更“优美”的方式，想想是什么。

对于内置的对象来说(比如整数、表、字符串等)，它们所需要的特殊方法都已经在 Python 中准备好了。而用户自己定义的对象也可以通过增加特殊方法，来实现自定义的语法。特殊方法比较靠近 Python 的底层，许多 Python 功能的实现都要依赖于特殊方法。我们将在以后看到更多的例子。

![](img/rdb_epub_1298541736268827882.jpg)

大黄蜂，还是 Camaro 跑车

Python 的许多语法都是基于其面向对象模型的封装。对象模型是 Python 的骨架，是功能完备、火力强大的大黄蜂。但是 Python 也提供更加简洁的语法，让你使用不同的编程形态，从而在必要时隐藏一些面向对象的接口。正如我们看到的 Camaro 跑车，将自己威风的火药库收起来，提供方便人类使用的车门和座椅。

如果你喜欢这篇文章，欢迎**推荐**。

如果你认为这篇文章值得更多人阅读，欢迎使用右侧的**“分享”**功能。

#### 技术推动进步，分享促进社区。