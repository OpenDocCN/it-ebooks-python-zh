## Python 进阶 04 函数的参数对应

[`www.cnblogs.com/vamei/archive/2012/07/08/2581264.html`](http://www.cnblogs.com/vamei/archive/2012/07/08/2581264.html)

作者：Vamei 出处：http://www.cnblogs.com/vamei 欢迎转载，也请保留这段声明。谢谢！

我们已经接触过函数(function)的参数(arguments)传递, 当时我们提到，参数是根据位置对应传递的。这一次，我们准备接触更多的参数对应方式。

首先，回忆一下根据位置传递：

```py
def f(a,b,c): print a,b,c

f(1,2,3)

```

在调用 f 时，1，2，3 根据位置分别传递给了 a,b,c。

1\. 关键字(keyword)参数传递

有时候，我们发现，在写程序时用位置传递会感觉比较死板。关键字传递就是根据每个参数的名字传递值，而不用遵守固定的位置。依然沿用上面 f 的定义，更改调用方式：

关键字传递可以和位置传递混用，但位置传递的参数必须在关键字传递的参数之前。

2\. 参数默认值(default)

在定义函数的时候，使用形如 a=19 的方式，可以给参数赋予默认值。如果该参数最终没有被传递值，将使用该默认值。

```py
def f(a,b,c=10): print a,b,c

f(3,2)
f(3,2,1)

```

在第一次调用函数 f 时， 我们并没有足够的值，c 没有被赋值，c 将使用默认值 10.

第二次调用函数的时候，c 被赋值为 1，不再使用默认值。

3\. 包裹(packing)位置传递和包裹关键字传递:

在定义函数时，我们有时候并不知道调用的时候会传递多少个函数。这时候，使用包裹位置传递和包裹关键字传递会非常有用。

下面是包裹位置传递的例子：

```py
def func(*name): print type(name) print name

func(1,4,6)
func(5,6,7,1,2,3)

```

上面的两次调用，尽管参数的个数不同，依然可以用同一个 func 定义。原因在于，在 func 的参数表中，所有的参数被 name 收集，根据位置合并成一个定值表(tuple)，这就是包裹位置传递。为了提醒 python 参数 name 是包裹位置传递所用的定值表名，在定义 func 时，在 name 前加*号。

下面是包裹关键字传递的例子：

```py
def func(**dict): print type(dict) print dict

func(a=1,b=9)
func(m=2,n=1,c=11)

```

与上面一个例子类似，dict 是一个字典，收集所有的关键字，传递给函数 func。为了提醒 python 参数 dict 是包裹关键字传递所用的字典，在 dict 前加**。

我们看到，包裹位置传递和包裹关键字传递的关键在于定义函数时，在相应定值表或字典前加*或**。

4\. 解包裹

*和**在调用的时候的应用，主要是解包裹(unpacking), 下面为例：

```py
def func(a,b,c): print a,b,c
args = (1,3,4)
func(*args)

```

在这个例子中，所谓的解包裹，就是在传递 tuple 时，让 tuple 的每一个元素对应一个位置参数。在这里，通过在调用 func 时使用*，我们提醒 python，我想要把 args 拆成分散的三个元素，分别传递给 a,b,c。（设想一下在调用 func 时，args 前面没有*会是什么后果？）

相应的，也存在对词典的解包裹，使用相同的 func 定义，然后：

```py
dict = {'a':1,'b':2,'c':3}
func(**dict)

```

在传递词典 dict 时，让词典的每个键值对作为一个关键字传递给 func。

5\. 混合定义与混合调用

参数的几种传递方式可以混合定义和混合调用。但在过程中要小心前后顺序。基本原则是，先位置，再关键字，再包裹位置，再包裹关键字，并且根据上面所说的原理细细分辨。

注意：本讲的内容，请注意定义时使用和调用时使用的区分。包裹和解包裹并不是相反操作，而是两个相对独立的过程。

总结： 

关键字，默认值，

包裹位置，包裹关键字 

解包裹